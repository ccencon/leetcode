# leetcode_0101_0150
|order|question|cpp link|
|:-|:-|:-|
|[0101](#0101)|[对称二叉树](#0101)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0101.cpp)|
|[0102](#0102)|[二叉树的层序遍历](#0102)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0102.cpp)|
|[0103](#0103)|[二叉树的锯齿形层序遍历](#0103)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0103.cpp)|
|[0104](#0104)|[二叉树的最大深度](#0104)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0104.cpp)|
|[0105](#0105)|[从前序与中序遍历序列构造二叉树](#0105)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0105.cpp)|
|[0106](#0106)|[从中序与后序遍历序列构造二叉树](#0106)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0106.cpp)|
|[0107](#0107)|[二叉树的层序遍历-ii](#0107)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0107.cpp)|
|[0108](#0108)|[将有序数组转换为二叉搜索树](#0108)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0108.cpp)|
|[0109](#0109)|[有序链表转换二叉搜索树](#0109)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0109.cpp)|
|[0110](#0110)|[平衡二叉树](#0110)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0110.cpp)|
|[0111](#0111)|[二叉树的最小深度](#0111)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0111.cpp)|
|[0112](#0112)|[路径总和](#0112)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0112.cpp)|
|[0113](#0113)|[路径总和-ii](#0113)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0113.cpp)|
|[0114](#0114)|[二叉树展开为链表](#0114)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0114.cpp)|
|[0115](#0115)|[不同的子序列](#0115)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0115.cpp)|
|[0116](#0116)|[填充每个节点的下一个右侧节点指针](#0116)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0116.cpp)|
|[0117](#0117)|[填充每个节点的下一个右侧节点指针-ii](#0117)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0117.cpp)|
|[0118](#0118)|[杨辉三角](#0118)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0118.cpp)|
|[0119](#0119)|[杨辉三角-ii](#0119)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0119.cpp)|
|[0120](#0120)|[三角形最小路径和](#0120)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0120.cpp)|
|[0121](#0121)|[买卖股票的最佳时机](#0121)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0121.cpp)|
|[0122](#0122)|[买卖股票的最佳时机-ii](#0122)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0122.cpp)|
|[0123](#0123)|[买卖股票的最佳时机-iii](#0123)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0123.cpp)|
|[0124](#0124)|[二叉树中的最大路径和](#0124)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0124.cpp)|
|[0125](#0125)|[验证回文串](#0125)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0125.cpp)|
|[0126](#0126)|[单词接龙-ii](#0126)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0126.cpp)|
|[0127](#0127)|[单词接龙](#0127)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0127.cpp)|
|[0128](#0128)|[最长连续序列](#0128)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0128.cpp)|
|[0129](#0129)|[求根节点到叶节点数字之和](#0129)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0129.cpp)|
|[0130](#0130)|[被围绕的区域](#0130)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0130.cpp)|
|[0131](#0131)|[分割回文串](#0131)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0131.cpp)|
|[0132](#0132)|[分割回文串-ii](#0132)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0132.cpp)|
|[0133](#0133)|[克隆图](#0133)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0133.cpp)|
|[0134](#0134)|[加油站](#0134)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0134.cpp)|
|[0135](#0135)|[分发糖果](#0135)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0135.cpp)|
|[0136](#0136)|[只出现一次的数字](#0136)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0136.cpp)|
|[0137](#0137)|[只出现一次的数字-ii](#0137)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0137.cpp)|
|[0138](#0138)|[复制带随机指针的链表](#0138)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0138.cpp)|

#### <span id=0101>[101] 对称二叉树</span>
题目链接：[https://leetcode-cn.com/problems/symmetric-tree](https://leetcode-cn.com/problems/symmetric-tree)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0101.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0101.cpp)  
运行时间：beats 76%  
解题思路：因为树是对称的数据结构，所以基于树的算法也必然能以对称方式实现；采用层级遍历root结点的左右子树，将左子树的左右结点与右子树的右左结点进行迭代比较即可
#### <span id=0102>[102] 二叉树的层序遍历</span>
题目链接：[https://leetcode-cn.com/problems/binary-tree-level-order-traversal](https://leetcode-cn.com/problems/binary-tree-level-order-traversal)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0102.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0102.cpp)  
运行时间：beats 100%  
解题思路：层序遍历的基本算法，额外的点在于如何确定每层个数；这里采用两个队列实现，下一层的结点将加入到另外一个队列，交替读取两个队列
#### <span id=0103>[103] 二叉树的锯齿形层序遍历</span>
题目链接：[https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0103.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0103.cpp)  
运行时间：beats 60.53%  
解题思路：与[[102] 二叉树的层序遍历](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150#0102)类似，这里不再叙述
#### <span id=0104>[104] 二叉树的最大深度</span>
题目链接：[https://leetcode-cn.com/problems/maximum-depth-of-binary-tree](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0104.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0104.cpp)  
运行时间：beats 100%  
解题思路：从根结点开始递归左右子树，取最大值加一；或者采用层级遍历的方式。还记得以前实现过栈形式的后序遍历，一个结点只有在左右子树迭代完之后才会出栈，所以栈实现的后序遍历也同样可以应用于计算树的最大深度，这里采用的也是此方法；值得注意的是，后序遍历的栈实现，需要一个额外结点用来记录上一次出栈结点，当再次取栈顶元素时，判断其右孩子是否与之相等来决定是否出栈
#### <span id=0105>[105] 从前序与中序遍历序列构造二叉树</span>
题目链接：[https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0105.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0105.cpp)  
运行时间：beats 37.3%  
解题思路：先序序列的组成，是`根结点+左子树的先序序列+右子树的先序序列`；而中序序列，是`左子树的中序序列+根结点+右子树的中序序列`；所以创建根结点，按照相同的方法递归创建其左右子树，即可构造出完成的二叉树

记得上述方法在数据结构教材中就有，但是一开始并不打算按照这种方式解答；在最初的思路中，是先通过中序序列构建一棵通过右指针连接的单链表树，然后希望通过观察先序序列的规律对其进行左旋从而得出正确的二叉树；因为左旋不改变树的中序，但却可以调整树的先序，潜意识里总觉得这思路可行，但最后要么转化成了递归，要么碰到了死角；由于在这思路上浪费了太多的时间，这里特地记录一下，也不再纠结了
#### <span id=0106>[106] 从中序与后序遍历序列构造二叉树</span>
题目链接：[https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0106.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0106.cpp)  
运行时间：beats 14.81%  
解题思路：与[[105] 从前序与中序遍历序列构造二叉树](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150#0105)一样的思路，其中后序序列的组成，是`左子树的后序序列+右子树的后序序列+根结点`
#### <span id=0107>[107] 二叉树的层序遍历-ii</span>
题目链接：[https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0107.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0107.cpp)  
运行时间：beats 5.12%  
解题思路：题目要求从最底层开始往最上层遍历，这在不知道所有底层结点和父结点的情况下不可能做到，所以只能是按照从顶层往下遍历的方式，最后反转列表。题目提示树的结点数在2000以内，一般情况下树的层数也只是在11层左右，所以解答中采用了头插法；测试用例应该有比较极端的情况，如类似单链表树，使得头插法会导致了过多元素移动，运行时间较长
#### <span id=0108>[108] 将有序数组转换为二叉搜索树</span>
题目链接：[https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0108.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0108.cpp)  
运行时间：beats 94.03%  
解题思路：每次选择数组中间的结点为根结点，左右序列作为左右子树，如此递归下去；因为左右子树结点数之差不会超过1，所以最终得到的树也必然是平衡二叉树
#### <span id=0109>[109] 有序链表转换二叉搜索树</span>
题目链接：[https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0109.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0109.cpp)  
运行时间：beats 88.9%  
解题思路：遍历链表，因为链表已经升序排列，所以只需不断在树的最右边增加新结点，然后进行左旋调整；树的旋转需要计算平衡因子，但一般平衡树的实现会在结点记录高度，如果在这里的实现中用额外空间给每一个结点记录高度，还不如直接将问题转化为[[108] 将有序数组转换为二叉搜索树](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150#0108)更加来得方便。留意到新结点的插入永远是位于树的最右边，那么在插入过程中，只需保存树最右边的路径和路径上结点的左子树高度，在插入后，沿着路径回溯，通过记录的左子树高度计算每一个结点的平衡因子，大于1便进行左旋，由于左旋后的树总体高度不变，所以仅需旋转一次

其实对于不断在树最右边进行插入，树的每一次左旋的时机都可以事先确认；在实现上述思路之前，便打算通过插入的结点数来确定要左旋的位置，不过随着结点数越来越多，计算左旋的位置也越来越复杂；在实现上述思路之后，便通过打印当前结点数来获得旋转位置；可以发现，当结点数为2n+3时（如3、5、7、9...），要左旋的位置为3；当结点数为4n+6时（如6、10、14、18...），要左旋的位置为4；当结点数为8n+12时（如12、20、28、36...），要左旋的位置为5...可以发现，当结点数满足 $(2n+1)*2^k, n>1$ 的时候，要左旋的位置为 $k+3$ ；这种规律可以在平衡二叉树上得到印证：当一棵树进行左旋时，假设往左偏了n个结点，那么这棵树必须补足n个结点才能使它的右子树恢复到这棵树原本的状态；比如一棵只有3个结点，通过右孩子连接的单支树，在往左旋转后，必须再往右补足2个结点才能使它此时的右子树恢复到它原本的状态

由于不可能每一个结点数都映射一个旋转位置，所以在具体实现中，上面两个思路的时间复杂度都为 $O(nlog_2 n)$

题解中有一种分治+中序遍历优化的方法可以达到 $O(n)$ 的时间复杂度，通过链表长度结合中序遍历按照先构建左子树的方式构建整棵树，虽然不喜欢要先遍历一次链表的做法，但这种思路值得记录一下
#### <span id=0110>[110] 平衡二叉树</span>
题目链接：[https://leetcode-cn.com/problems/balanced-binary-tree](https://leetcode-cn.com/problems/balanced-binary-tree)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0110.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0110.cpp)  
运行时间：beats 87.96%  
解题思路：递归计算左右子树高度进行判断即可
#### <span id=0111>[111] 二叉树的最小深度</span>
题目链接：[https://leetcode-cn.com/problems/minimum-depth-of-binary-tree](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0111.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0111.cpp)  
运行时间：beats 92.09%  
解题思路：对树进行层级遍历，当遇到没有左右孩子的结点时返回层数
#### <span id=0112>[112] 路径总和</span>
题目链接：[https://leetcode-cn.com/problems/path-sum](https://leetcode-cn.com/problems/path-sum)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0112.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0112.cpp)  
运行时间：beats 82.68%  
解题思路：计算路径上结点的数字总和，需要在路径回溯时减去回溯结点的值，如果不使用递归，可以使用后序遍历的栈实现方式，这种方式在遍历时会保留完整的路径，回溯时可以减去相应结点的值
#### <span id=0113>[113] 路径总和-ii</span>
题目链接：[https://leetcode-cn.com/problems/path-sum-ii](https://leetcode-cn.com/problems/path-sum-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0113.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0113.cpp)  
运行时间：beats 94.1%  
解题思路：比[[112] 路径总和](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150#0112)多了一个路径返回操作，把记录路径的容器由stack改为vector，当遇到符合的路径时，便将当前路径记录到返回集合中
#### <span id=0114>[114] 二叉树展开为链表</span>
题目链接：[https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0114.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0114.cpp)  
运行时间：beats 88.48%  
解题思路：先序序列是`根结点+左子树先序序列+右子树先序序列`，在将当前结点转化为链表前，用栈记录右子树的根结点，然后记录左子树的根结点，这样的出栈顺序将会演变为先序序列的顺序，按照这个顺序构造链表
#### <span id=0115>[115] 不同的子序列</span>
题目链接：[https://leetcode-cn.com/problems/distinct-subsequences](https://leetcode-cn.com/problems/distinct-subsequences)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0115.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0115.cpp)  
运行时间：beats 98.05%  
解题思路：回溯类解法，类似[[51] n-皇后](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100#0051)。将s和t从前往后匹配，用数组记录s的匹配下标，当匹配完成时，对数组记录的下标进行回溯，在原来的基础上往右偏移一位进行重新匹配。对于字符串这类题目，会存在许多重复子串的比较，基本上都需要记忆化搜索进行优化。在本题，记忆化在于记录s中每一个位置可以匹配t中剩余字符的序列数；举个例子，假设s与t完成了一次匹配，这时候坐标数组分别记录了a，b，c，d，表示s的a，b，c，d四个位置匹配了整个t串，那么(c,d]，(b,c]，(a,b]区间内对应的匹配数如mem[d][3]，mem[b][1]将会增加1，mem表示记忆化数组，两个坐标分别对应s和t的匹配位置，以mem[d][3]为例，表示的就是从s的下标d开始匹配t从下标3开始的子序列数

回溯+记忆化的思路总体上有点隐晦难懂，这是为了锻炼思维能力的选择；相比之下递归永远更加容易理解，解决方案中同样以递归的方式进行了解答；动态规划也是本题解答方法之一，一般来说动态规划可以看作递归的另外一种形式，官方题解对动态规划有详细的解释，这里不再叙述
#### <span id=0116>[116] 填充每个节点的下一个右侧节点指针</span>
题目链接：[https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0116.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0116.cpp)  
运行时间：beats 87.76%  
解题思路：按照广度优先的层序遍历即可完成解答，这应该算一道简单题
#### <span id=0117>[117] 填充每个节点的下一个右侧节点指针-ii</span>
题目链接：[https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0117.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0117.cpp)  
运行时间：beats 96.43%  
解题思路：如果不理会进阶要求，这跟[[116] 填充每个节点的下一个右侧节点指针](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150#0116)是一样的思路；进阶要求使用常数级的额外空间，而列队做法的空间复杂度为 $O(n/2)$，故其不再适用；因为每一层的结点都是通过next指针连接，可以基于树的顶层连接第二层并保留第二层的起始结点，下一次迭代将从这个起始结点开始再次连接下一层，当起始结点为空时，表明已经连接了最底层，迭代结束
#### <span id=0118>[118] 杨辉三角</span>
题目链接：[https://leetcode-cn.com/problems/pascals-triangle](https://leetcode-cn.com/problems/pascals-triangle)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0118.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0118.cpp)  
运行时间：beats 36.63%  
解题思路：从第二行开始遍历每一行，每一行除首位外位置的数值等于左上方和右上方两数之和
#### <span id=0119>[119] 杨辉三角-ii</span>
题目链接：[https://leetcode-cn.com/problems/pascals-triangle-ii](https://leetcode-cn.com/problems/pascals-triangle-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0119.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0119.cpp)  
运行时间：beats 100%  
解题思路：还记得高中课本在介绍杨辉三角的时候，将杨辉三角与二项式还有斐波那契数列联系在一起，每一行的数值可以不需要借助上一行计算出来；这题目要求返回某一行数列，如果按照[[118] 杨辉三角](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150#0118)的做法将会多出不必要的推导过程；在温习相关知识后发现，杨辉三角每一行都复合二项式展开，那么只需要计算相关的组合数即可，如第n+1行的第个m+1位置，数值为 $C_{n}^{m}$ ，这个数值可以反推杨辉三角，因为 $C_{n}^{m}=C_{n-1}^{m-1} + C_{n-1}^{m}$ ，等式右边两个数恰好对应了杨辉三角第n+1行第个m+1位置的左上方和右上方两个位置

计算组合数要注意溢出问题，这里又犯了这个错误，特地记录一下。如计算 $C_{n}^{m}$ ，应该将计算转化为 $\frac{n-m+1}{1}×\frac{n-m+2}{2}×\frac{n-m+3}{3}...×\frac{n}{m}$ ，按照顺序从左往右，先乘后除，这样既不会溢出，也不会损失精度；在组合数比较多的情况下，还可以采用数组进行记忆化储存
#### <span id=0120>[120] 三角形最小路径和</span>
题目链接：[https://leetcode-cn.com/problems/triangle](https://leetcode-cn.com/problems/triangle)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0120.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0120.cpp)  
运行时间：beats 2.26%  
解题思路：最开始看到这题的时候，不由自主的便将它与图进行了联想，脑海里第一个浮现的解决方案就是使用图算法中的Dijkstra或Floyd算法进行求解，因为是求三角形顶点到底部各点的最短路径，Dijkstra会更加适用；Dijkstra借助小顶堆，每次都取出当前权重最小的路径进行求解，要求路径中点的权重不能存在负数，如果存在负数，小顶堆的数据结构将不会有任何意义，因为这时候必须遍历完图中所有点才知道最短路径；这次的运行时间极度不理想，原因就是在于三角形各点权重存在负数

同样可以使用DFS或BFS进行求解，使用DFS，类似二叉树的中序遍历，能往左走往左走，左走返回时能往右走往右走；可以优化的点在于记录每一个结点的最小权重，如果走到重复的点发现新权重大于旧权重便不用再走下去了

BFS的方法与题解中dp的思路一致，其实题解中的dp本质也是BFS；按照逐行逐列的方式，计算出当前点的最小权重，最后返回末尾一行的最小权重；可以优化的点在于从底往上遍历，因为第1行只有一个权重，当遍历到第一行时直接返回其权重便可
#### <span id=0121>[121] 买卖股票的最佳时机</span>
题目链接：[https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0121.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0121.cpp)  
运行时间：beats 33.08%  
解题思路：采用双指针做法，设定left从0，right从1开始，当right指向的数比left指向的数小时，将right赋值给left；当right指向的数比left指向的数大时，刷新最大差值；right往后移动，直至到达数组末尾
#### <span id=0122>[122] 买卖股票的最佳时机-ii</span>
题目链接：[https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0122.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0122.cpp)  
运行时间：beats 90.41%  
解题思路：不限制购买次数，可以看作实际股市中的做波段，低位买，高位卖；只需要遍历数组找到每一个单调递增区间，加上其差值即可
#### <span id=0123>[123] 买卖股票的最佳时机-iii</span>
题目链接：[https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0123.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0123.cpp)  
运行时间：beats 17.79%  
解题思路：没做出来，最开始的想法跟前面类似，在遍历中找出单调递增区间，但无法处理区间重合的情况，想了很久还是不能解决。在浏览题解之后得到两种解决方法，下面记录一下自己的理解：

> 递归

对于每一天，可以选择的操作是：`不动`，`在已卖的前提下买`，`在已买的前提下卖`；基于此，可以创建递归思路，对每一天的最大收益，递归判断，是不动的收益大，还是买/卖的收益大；对于买还是卖，可以设定一个status从0开始，买卖一次都递增一次，即整除2时可买，否则就是卖，题目限定了最大交易次数为2，当遍历到数组末尾，或者status等于4时递归进行返回；可以采用记忆化进行优化，在递归过程中记录每一次的最大利润

> 动态规划

为了方便理解，可以把动态规划的求解过程划分为4个子过程：

假设 $prices=[4,1,2,5,2,4]$

##### 1. 求在完成第一次买操作下每天的最大利润
以上述prices为例，第一天的最大利润为-4，因为第一天只能在第一天进行购买；第二天利润为-1，因为在第二天可以选择第一天或第二天进行购买，这里毫无疑问选择第二天；依据这个思路，求得在完成第一次买操作下每天的最大利润 $p_1=[-4,-1,-1,-1,-1,-1]$ ，即 $p_1[i]=\max(p_1[i-1],-prices[i])$

##### 2. 求在完成第一次卖操作下每天的最大利润
求在完成第一次卖操作下每天的最大利润需要依据上面已计算的结果；第一天时，只能选择当天卖出，利润为0；第二天时，选择当天卖出，利润为0，当天买卖；第三天时，同样选择当天利润卖出，利润为1，即第二天买，第三天卖；依据这个思路，第四天的利润是最高的，到了第五，第六天，因为其当天卖出的利润都比不上第4天，所以这两天的最大利润都是第四天的利润； $p_2=[0,0,1,4,4,4]$ ，即 $p_2[i]=\max(p_2[i-1],p_1[i]+prices[i])$

##### 3. 求在完成第二次买操作下每天的最大利润
同理， $p_3=[-4,-1,-1,-1,2,2]$ ，即 $p_3[i]=\max(p_3[i-1],p_2[i]-prices[i])$

##### 4. 求在完成第二次卖操作下每天的最大利润
同理， $p_4=[0,0,1,4,4,6]$ ，即 $p_4[i]=\max(p_4[i-1],p_3[i]+prices[i])$

可以发现，上述4个子过程有着严格的执行顺序，而每一天的状态也只需依赖前一天的状态，那么只需要遍历一次prices即可得出解；题目要求交易次数不超过2次，在上面的求解过程中，当天买卖的操作可以看作不交易，最终的p4必然复合题意

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int buy1 = -prices[0], sell1 = 0;
        int buy2 = -prices[0], sell2 = 0;
        for (int i = 1; i < n; ++i) {
            buy1 = max(buy1, -prices[i]);
            sell1 = max(sell1, buy1 + prices[i]);
            buy2 = max(buy2, sell1 - prices[i]);
            sell2 = max(sell2, buy2 + prices[i]);
        }
        return sell2;
    }
};
/*
作者：力扣官方题解
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/solutions/552695/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/
```
#### <span id=0124>[124] 二叉树中的最大路径和</span>
题目链接：[https://leetcode-cn.com/problems/binary-tree-maximum-path-sum](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0124.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0124.cpp)  
运行时间：beats 58.19%  
解题思路：递归计算左右子树的最大路径和，将它们与根结点进行运算计较，取出一条最大路径作为上一级递归的返回，这个最大路径可以是当前`根结点`，也可以是`根结点+左子树的最大路径`，也可以是`根结点+右子树的最大路径`；需要在递归过程外设定一个变量记录整棵树的最大路径和，另外一点，`根结点+左子树的最大路径+右子树的最大路径`虽然不能作为子树的最大路径返回，但却可以组成一条新的路径，在计算出左右子树的最大路径后，需要判断这种情况
#### <span id=0125>[125] 验证回文串</span>
题目链接：[https://leetcode-cn.com/problems/valid-palindrome](https://leetcode-cn.com/problems/valid-palindrome)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0125.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0125.cpp)  
运行时间：beats 85.51%  
解题思路：双指针从两边往中间遍历，遇到非字母数字字符跳过，比较两边字符直至两指针相遇
#### <span id=0126>[126] 单词接龙-ii</span>
题目链接：[https://leetcode-cn.com/problems/word-ladder-ii](https://leetcode-cn.com/problems/word-ladder-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0126.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0126.cpp)  
运行时间：beats 95.37%  
解题思路：这是目前为止在leetcode提交过最长，最蛋痛的代码，提交前已经做好了超时准备，但没想到最终结果居然能打败90%多，虽然出乎意料，但这也证实了解题思路的正确性。题目需要求一个单词到另外一个单词的最小转换次数，不妨把单词看作图的一个结点，两个可以直接转换的单词存在连通关系，即可以组成一条边；求两个单词最小转换次数，就可以看作求图中两个结点的不带权最短路径，这一步只需简单的BFS即可解决。手撕过[无向图](https://github.com/ccencon/structdata#UnDirectedGraph)和[有向图](https://github.com/ccencon/structdata#DirectedGraph)的所有基础算法，这个实现还是非常简单的，但这题的细节实现却非常让人头痛，下面记录一下：

1. `结点的连通关系判定`，最粗暴的解决方法就是以 $O(n^2)$ 的时间复杂度判定每一个单词与其它所有未判定单词间的连通关系；想过很多方法优化这一步，如哈希等，最后发现这一步好像根本没办法优化，最终还是采用了这种（唯一？）暴力方法
2. `beginWord不必是字典wordList中的单词`，这也是很让人头痛的一点，甚至在开始我还觉得翻译有问题，意思应该是beginWord不会存在于字典中。beginWord存在于字典，会导致连通关系的判定出现两个抉择：

    1. 先判定wordList中所有单词的连通关系，在判定过程额外判断beginWord是否存在于wordList；在连通关系判定结束后，如果beginWord不存在于wordList，那就再执行一次beginWord与wordList中所有单词的连通关系判定
    2. 先对wordList进行一次遍历，找出beginWord是否存在于wordList，如果不存在就把beginWord加到wordList的末尾，最后统一对wordList中的单词进行连通判定

    这两种不同的方式会导致后面的实现出现不一样的编程细节，在纠结很久后，选择了第二种

3. `多条路径`，在无向图构建完成后，可以很轻易的通过BFS得出一条路径，但题目要求返回所有路径，这也使得BFS的形式更加复杂，在BFS标记所有路径之后，还需要借助回溯或者递归进行最后的字符串赋值
#### <span id=0127>[127] 单词接龙</span>
题目链接：[https://leetcode-cn.com/problems/word-ladder](https://leetcode-cn.com/problems/word-ladder)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0127.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0127.cpp)  
运行时间：beats 23.96%  
解题思路：与[单词接龙-ii](#0126)一样的思路，按照题目要求去掉最后回溯的一步，只需返回最少转换次数；但同一个思路的两次运行时间相差较大，看了下官方题解的做法，发现差别在于结点的连通性判定，官方做法是：

> 具体地，我们可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 \*it、h\*t、hi\*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可

这种建图的方式时间复杂度为 $O(N×C)$，其中 $N$ 为字典长度， $C$ 为单词长度，但这个时间复杂度太过理想化，因为按照这种方法需要借助哈希表存放所有单词；总的来说，两种方法的运行时间比较依赖于测试用例，在字典单词较长，差异性较大的情况下，暴力法应该会有更好的表现
#### <span id=0128>[128] 最长连续序列</span>
题目链接：[https://leetcode-cn.com/problems/longest-consecutive-sequence](https://leetcode-cn.com/problems/longest-consecutive-sequence)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0128.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0128.cpp)  
运行时间：beats 39.63%  
解题思路：最开始的思路是构建一条路径path，插入nums[i]时，如果nums[i]-1已经存在（借助哈希表保存值和索引，假设索引为j），便把path[i]=j，nums[i]+1同理，最后再遍历一次数组找到最长连续序列；这个思路最后这一步会存在重复遍历路径的情况，于是把这个思路转换成了并查集，在最开始遍历的时候合并相近数字，使同一个集合内最小数指向最大数，最后遍历时，找出父结点的数值减去当前数值再加1，并刷新最大序列数；不过并查集的插入和查找的时间复杂度近似 $O(n)$ ，循环和并查集结合就接近了 $O(n^2)$ ，题目要求 $O(n)$ 的时间复杂度，这显然不符合题意；在想不出更好方案的情况下最后还是以这种不太能接受的思路提交。官方题解更加巧妙，记录一下：

1. 先遍历一次数组，把各个数值加到哈希表中
2. 再遍历一次数组，如果当前数值-1不存在于哈希表中，说明这个数值是某个序列的最小数，把当前数值不断加1，直到在哈希表中找不到，刷新最大序列数；如果当前数值-1存在哈希表，说明当前数值在序列中不是最小值，跳过

官方题解巧妙在判断要计算序列数的情况，只有当前数值为序列中最小值才会执行计算，时间复杂度为 $O(n)$ 
#### <span id=0129>[129] 求根节点到叶节点数字之和</span>
题目链接：[https://leetcode-cn.com/problems/sum-root-to-leaf-numbers](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0129.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0129.cpp)  
运行时间：beats 100%  
解题思路：递归处理，遇到非叶子结点乘10加上当前结点值，遇到叶子结点就加上总和返回；在这种情况下递归会比非递归的效率高，因为非递归在回溯时需要除以10还原值
#### <span id=0130>[130] 被围绕的区域</span>
题目链接：[https://leetcode-cn.com/problems/surrounded-regions](https://leetcode-cn.com/problems/surrounded-regions)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0130.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0130.cpp)  
运行时间：beats 13.85%  
解题思路：深度优先、广度优先、并查集都可以解答这题，但并查集的效率应该会低一点，
原因在于并查集在创建集合之后需要初始化父结点指向自身，c++中`vector::vector(size_type n)`这个构造函数会为没有写构造函数的类对象做清零操作，其中就包括int类型，这就使得使用并查集解答需要两次赋值操作；虽然深度优先、广度优先也需要一个额外数组判定坐标是否已经被遍历，但这个数组是布尔类型且可以在创建的同时完成初始化，只需一次赋值操作；另外一点在于并查集的合并和查询，这两个操作合在一起理论上是 $O(n)$ 的时间复杂度。不过鉴于目前并查集算法使用得比较少，这题的解答方式便使用了并查集；具体思路是：先遍历一次数组，把当前'O'的坐标与上面和左边的'O'的坐标（如果存在）合并在一起，如果是处于矩阵边上的'O'，还需要与(0, 0)这个坐标合并（为了方便判断，也可以选择其它边上的坐标）；最后遍历一次数组，遇到'O'时，如果其坐标的父结点与(0, 0)这个坐标父结点不是同一个，说明与矩阵边界不连通，置为'X'
#### <span id=0131>[131] 分割回文串</span>
题目链接：[https://leetcode-cn.com/problems/palindrome-partitioning](https://leetcode-cn.com/problems/palindrome-partitioning)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0131.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0131.cpp)  
运行时间：beats 99.9%  
解题思路：回溯类问题，从字符串起始位置开始，每段子串长度取1，判断是否回文串，然后从最后的位置逐步回溯，长度+1，重复以上操作。这类问题还需要进行记忆化，对于某段子串，在回溯再往后操作的过程中，会存在多次相同的判断，可以使用记忆数组，保存子串起始和结束两个下标的回文串判断结果，当下次进行重复判断时，直接从记忆数组取出判断结果
#### <span id=0132>[132] 分割回文串-ii</span>
题目链接：[https://leetcode-cn.com/problems/palindrome-partitioning-ii](https://leetcode-cn.com/problems/palindrome-partitioning-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0132.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0132.cpp)  
运行时间：beats 5.07%  
解题思路：使用了与[[131] 分割回文串](#0131)类似的回溯思路求解；在最开始的时候拿131的代码过来修改，然后提交，预料之中的超时；对超时测试用例进行跟踪调试发现，在回溯过程中，假设从下标10回溯到下标9，因为是从下标10开始穷举所有情况，所以下标10的最小分割次数已经可以确定，基于此可以使用另外一个记忆化数组记录从下标10开始的最小分割次数，当下一次从下标10开始计算最小分割次数时，就不用再穷举下去，直接从记忆化数组取出结果即可；再次提交，AC，但是用时800ms+，寻找可以优化的点，发现在刷新某下标的最小分割次数时，如果其最小分割次数已经为0，则可以立即返回，因为没有比0小的分割次数了；再次提交，用时降到500ms+，再次尝试寻找可以优化的点，发现可以使每次判断回文串的长度从1开始自增改为从最大值开始递减，因为题目是求最小分割次数，就必须尽可能使得每个子串最长；再次提交，用时降到300ms+；但这三次优化提交，运行时间都只是打败了5.07%，效果不太理想

尝试使用动态规划的思想去解答，但想不通状态应该如何转移，在阅读官方动态规划的思路后，发现对动态规划的理解还是太过狭隘
#### <span id=0133>[133] 克隆图</span>
题目链接：[https://leetcode-cn.com/problems/clone-graph](https://leetcode-cn.com/problems/clone-graph)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0133.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0133.cpp)  
运行时间：beats 84.82%  
解题思路：看完题目后就在脑海里描绘出了dfs，bfs两种解决方案，这得益于以前手撕过[邻接多重表实现的无向图](https://github.com/ccencon/structdata#UnDirectedGraph)和[十字链表实现的有向图](https://github.com/ccencon/structdata#DirectedGraph)。本次解答采用了dfs、bfs、dfs+bfs三种方案；其中dfs+bfs可以看作是bfs的变种，说简单点就是把存储结点的容器由队列改为栈，在加入当前结点的所有邻接结点之后，首先出栈的永远都是最后加入的结点，这样就使得遍历方式一半广度一半深度；其实不论何种遍历方式，只要能正确完成遍历，都是可取的
#### <span id=0134>[134] 加油站</span>
题目链接：[https://leetcode-cn.com/problems/gas-station](https://leetcode-cn.com/problems/gas-station)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0134.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0134.cpp)  
运行时间：beats 70.29%  
解题思路：假设汽车可以欠油行驶，并且从索引为0的加油站开始出发，那么在行驶过程中，汽车如果欠越来越多的油，则说明符合条件的加油站必然位于当前加油站后面，由于只有一个加油站符合条件，可以假定符合条件的加油站索引为当前加油站索引+1，这个索引随着汽车行驶是否欠更多的油而刷新；在行驶一圈之后，如果汽车还欠油，则说明汽车不能完成行驶，否则所记录的加油站索引就是正确的解
#### <span id=0135>[135] 分发糖果</span>
题目链接：[https://leetcode-cn.com/problems/candy](https://leetcode-cn.com/problems/candy)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0135.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0135.cpp)  
运行时间：beats 83.79%  
解题思路：遍历数组，找出单调递增区间和单调递减区间；对于单调递增区间，最少糖果数必然是按照左端点到右端点的方向从1开始递增；对于单调递减区间，最少糖果数必然是按照右端点到左端点的方向从1开始递增；需要注意的是单调递增区间和单调递减区间重叠的端点，它必须取最大值，如序列 $ratings=[1,2,4,3,2,1]$ ，索引0-2为单调增区间，索引2-5为单调减区间，索引2作为这两个区间重叠的端点，最大值必须为右边区间的4，而非左区间的3
#### <span id=0136>[136] 只出现一次的数字</span>
题目链接：[https://leetcode-cn.com/problems/single-number](https://leetcode-cn.com/problems/single-number)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0136.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0136.cpp)  
运行时间：beats 66.08%  
解题思路：非常出名的一道题，记得很久之前就已经接触过；利用异或的特性进行解答，异或是相同位为0，不同位为1，这使得相同的两个数异或之后为0，而0异或任何数都为被异或数本身，加之异或满足交换律，只需遍历一次数组，异或上每一个数，最终的结果即为解
#### <span id=0137>[137] 只出现一次的数字-ii</span>
题目链接：[https://leetcode-cn.com/problems/single-number-ii](https://leetcode-cn.com/problems/single-number-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0137.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0137.cpp)  
运行时间：beats 100%  
解题思路：没做出来，思考方向是通过与或非等位运算操作一次数组，尝试转化为136的情况，但最后发现这根本不可行，这些操作只是把所有数字迁移到另外一种对称状态，最终所要面临的情况都是一样的。下面以个人理解记录一下[官方题解](https://leetcode.cn/problems/single-number-ii/solutions/746993/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetc-23t6/)的推导过程：

> 过程1

通过确定最终答案的每一个比特位得出答案；由于数组中除了答案数字，其它所有数字都只出现3次，而相同数字的相同比特位只能是0或1，所以数组中除了答案数字外，其它所有数字的相同比特位之和 $sum_i$ 必然能被3整除，而 $sum_i$ 加上答案数字相应的比特位之后，除以3的余数即为答案数字对应的比特位

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int total = 0;
            for (int num: nums) {
                total += ((num >> i) & 1);
            }
            if (total % 3) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
};
/*
作者：力扣官方题解
链接：https://leetcode.cn/problems/single-number-ii/solutions/746993/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetc-23t6/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/
```

可以发现，无论数组中重复出现的数字有多少个，都可以按照这个思路求出解

> 过程2

过程1的时间复杂度为 $O(32n)$ ，为使其达到纯粹的 $O(n)$ ，可以引入数字电路的思想同时处理所有比特位。留意到过程1中，每个比特位在相加之后，它的余数要么是加0不变，要么是加1按照1→2→0的顺序循环出现；从数电的角度来看，可以把相加之前的两个比特（余数和数组新遍历的数）看作输入，相加之后的比特（余数）看作输出；由于比特位只能是0或1，为了兼顾余数为2这种情况，可以使用 $a$ 和 $b$ 两个数来记录余数的每个比特位状态；假设 $a_i$ 和 $b_i$ 表示答案数字（余数）第 $i$ 个比特位的状态， $x_i$ 为当前遍历到整数的第 $i$ 个比特位，由上述逻辑可以得出如下真值表：

| $a_i$ | $b_i$ | $x_i$ | 新的 $a_i$ | 新的 $b_i$ |
|:-:|:-:|:-:|:-:|:-:|
|0|0|0|0|0|
|0|0|1|0|1|
|0|1|0|0|1|
|0|1|1|1|0|
|1|0|0|1|0|
|1|0|1|0|0|

根据真值表得到 $a_i$ 和 $b_i$ 的逻辑代数公式：

$a_i=\overline{a_i}b_ix_i+a_i\overline{b_i}\overline{x_i}$ 

$b_i=\overline{a_i}\overline{b_i}x_i+\overline{a_i}b_i\overline{x_i}=\overline{a_i}(b_i\oplus{x_i})$ 

将电路逻辑运算转换成等价的整数位运算，得出：

$a=(\tilde{a} \cdot b \cdot x) \mid (a \cdot \tilde{b} \cdot \tilde{x})$

$b=\tilde{a} \cdot (b\oplus{a})$

在遍历完数组所有数字之后， $a_ib_i$ 要么是00（对应余数为0），要么是01（对应余数为1），所以最终答案只需返回 $b$ ；其实按照这种思路，无论余数有多大，参与计算整数有多少个（比如余数为4，就需要3个数参与运算），最低位整数的比特位永远都是唯一数的比特位

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int a = 0, b = 0;
        for (int num: nums) {
            tie(a, b) = pair{(~a & b & num) | (a & ~b & ~num), ~a & (b ^ num)};
        }
        return b;
    }
};
/*
作者：力扣官方题解
链接：https://leetcode.cn/problems/single-number-ii/solutions/746993/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetc-23t6/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/
```
在官方的这个推导过程中， $a_i$ 的计算过于复杂，可以引入无关状态进行化简；留意到上面真值表没有讨论 $a_i=1,b_i=1,x_i=0$ 和 $a_i=1,b_i=1,x_i=1$ 的情况，这两种情况在实际中不会发生，但为了进一步化简 $a_i$ 的计算，可以假定会发生这两种情况，且输出为1，那么 $a_i$ 的电路逻辑代数将会演变如下：

$a_i=\overline{a_i}b_ix_i+a_i\overline{b_i}\overline{x_i}+a_ib_i\overline{x_i}+a_ib_ix_i=b_ix_i(a_i+\overline{a_i})+a_i\overline{x_i}(b_i+\overline{b_i})=b_ix_i+a_i\overline{x_i}$ 

上述代码中a，b赋值对应转变为：

```c++
tie(a, b) = pair{(b & num) | (a & ~num), ~a & (b ^ num)};
```

可以发现，对于 $a_i$ 的计算，可以减少4次位运算

> 过程3

过程3是对过程2中计算 $a_i$ 的一个优化，目的就是减少 $a_i$ 的位运算次数，采用的优化方案是先计算出 $b_i$ ，将新算出的 $b_i$ 替代真值表中原本的 $b_i$ ，得出 $a_i$ 的另一个逻辑电路函数，公式如下：

$b_i=\overline{a_i}(b_i\oplus{x_i})$ 

$a_i=\overline{b_i}(a_i\oplus{x_i})$ 

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int a = 0, b = 0;
        for (int num: nums) {
            b = ~a & (b ^ num);
            a = ~b & (a ^ num);
        }
        return b;
    }
};
/*
作者：力扣官方题解
链接：https://leetcode.cn/problems/single-number-ii/solutions/746993/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetc-23t6/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/
```
#### <span id=0138>[138] 复制带随机指针的链表</span>
题目链接：[https://leetcode-cn.com/problems/copy-list-with-random-pointer](https://leetcode-cn.com/problems/copy-list-with-random-pointer)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0138.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0101_0150/cpp/leetcode_0138.cpp)  
运行时间：beats 76.16%  
解题思路：通过next指针遍历原有链表，创建新结点，以原结点为索引，把新结点加入到哈希表中；判断原结点的next和random指针，不为空则继续创建对应的新结点并加入到哈希表，完善新结点间的连接关系，然后进入下一轮迭代
