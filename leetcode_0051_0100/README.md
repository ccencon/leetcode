# leetcode_0051_0100
|order|question|cpp link|
|:-|:-|:-|
|[0051](#0051)|[n-皇后](#0051)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0051.cpp)|
|[0052](#0052)|[n皇后-ii](#0052)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0052.cpp)|
|[0053](#0053)|[最大子数组和](#0053)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0053.cpp)|
|[0054](#0054)|[螺旋矩阵](#0054)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0054.cpp)|
|[0055](#0055)|[跳跃游戏](#0055)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0055.cpp)|
|[0056](#0056)|[合并区间](#0056)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0056.cpp)|
|[0057](#0057)|[插入区间](#0057)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0057.cpp)|
|[0058](#0058)|[最后一个单词的长度](#0058)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0058.cpp)|
|[0059](#0059)|[螺旋矩阵-ii](#0059)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0059.cpp)|
|[0060](#0060)|[排列序列](#0060)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0060.cpp)|
|[0061](#0061)|[旋转链表](#0061)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0061.cpp)|
|[0062](#0062)|[不同路径](#0062)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0062.cpp)|
|[0063](#0063)|[不同路径-ii](#0063)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0063.cpp)|
|[0064](#0064)|[最小路径和](#0064)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0064.cpp)|
|[0065](#0065)|[有效数字](#0065)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0065.cpp)|
|[0066](#0066)|[加一](#0066)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0066.cpp)|
|[0067](#0067)|[二进制求和](#0067)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0067.cpp)|
|[0068](#0068)|[文本左右对齐](#0068)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0068.cpp)|
|[0069](#0069)|[x-的平方根](#0069)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0069.cpp)|
|[0070](#0070)|[爬楼梯](#0070)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0070.cpp)|
|[0071](#0071)|[简化路径](#0071)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0071.cpp)|
|[0072](#0072)|[编辑距离](#0072)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0072.cpp)|
|[0073](#0073)|[矩阵置零](#0073)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0073.cpp)|
|[0074](#0074)|[搜索二维矩阵](#0074)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0074.cpp)|
|[0075](#0075)|[颜色分类](#0075)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0075.cpp)|
|[0076](#0076)|[最小覆盖子串](#0076)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0076.cpp)|
|[0077](#0077)|[组合](#0077)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0077.cpp)|
|[0078](#0078)|[子集](#0078)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0078.cpp)|
|[0079](#0079)|[单词搜索](#0079)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0079.cpp)|
|[0080](#0080)|[删除有序数组中的重复项-ii](#0080)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0080.cpp)|
|[0081](#0081)|[搜索旋转排序数组-ii](#0081)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0081.cpp)|
|[0082](#0082)|[删除排序链表中的重复元素-ii](#0082)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0082.cpp)|
|[0083](#0083)|[删除排序链表中的重复元素](#0083)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0083.cpp)|
|[0084](#0084)|[柱状图中最大的矩形](#0084)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0084.cpp)|
|[0085](#0085)|[最大矩形](#0085)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0085.cpp)|
|[0086](#0086)|[分隔链表](#0086)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0086.cpp)|

#### <span id=0051>[51] n-皇后</span>
题目链接：[https://leetcode-cn.com/problems/n-queens](https://leetcode-cn.com/problems/n-queens)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0051.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0051.cpp)  
运行时间：beats 91.39%  
解题思路：对这类回溯的问题，只要理清如何恢复状态的思路，很容易就可以写出非递归的实现，基本上就是三板斧：  
1. 初始回溯标志，一般为某个索引或索引集合，假定为traceIdx
2. 从traceIdx开始到结束确定一个新的序列，每一个位置确定的状态应该具有次序性，这样回溯的时候可以容易确定下一个状态
3. 回溯traceIdx，从后往前恢复状态，当某个位置有未执行的状态时，转到步骤2执行；若回溯了所有位置，结束执行

这种思路的解答运行时间基本都是击败100%，目前在网上还没见到类似思路的出现，都是递归或其它，这来源于当初写[有向图](https://github.com/ccencon/structdata#DirectedGraph)输出所有拓扑序列和所有关键路径的做法，在当前所有回溯类的题目中，基本上采用了这种解答方式  

这题的具体做法是，设定数组保存每一行，每一列，每一条斜线的匹配状态，初始trace_i，trace_j，从开始到结束确定第一个结果，然后对trace_i，trace_j进行回溯并恢复状态，并从新的trace_i，trace_j开始确定新的结果
#### <span id=0052>[52] n皇后-ii</span>
题目链接：[https://leetcode-cn.com/problems/n-queens-ii](https://leetcode-cn.com/problems/n-queens-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0052.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0052.cpp)  
运行时间：beats 100%  
解题思路：[n-皇后](#0051)一样的做法，只是将返回字符串换成了返回个数，本质上没有变化
#### <span id=0053>[53] 最大子数组和</span>
题目链接：[https://leetcode-cn.com/problems/maximum-subarray](https://leetcode-cn.com/problems/maximum-subarray)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0053.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0053.cpp)  
运行时间：beats 71.26%  
解题思路：设定prev记录以当前位置结束的最大子数组和，ans记录最大子数组和，遍历到某个pos时，如果prev + nums[pos] < nums[pos]，则prev = nums[pos]，否则prev = prev + nums[pos]，然后刷新ans
#### <span id=0054>[54] 螺旋矩阵</span>
题目链接：[https://leetcode-cn.com/problems/spiral-matrix](https://leetcode-cn.com/problems/spiral-matrix)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0054.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0054.cpp)  
运行时间：beats 100%  
解题思路：哀过程之多艰，这道中等题足足花费了两天的零碎时间。如果按照一般套路来做的话，这道题其实可以归纳为简单题，具体有两种做法：一种是给螺旋轨迹设定一个运动规则，右→下→左→上，即每运动到一个点，便依次判断右下左上是否已经到达过，选出下一个未到达过的点，直至所有点均与到达，但这种方式会存在较多分支判断，可以采用另外一种方法；另外一种方法是模拟旋转路径，按照运动轨迹一层一层地遍历，先往右走，遇到边界往下走，再然后往左走，最后往上走  

在开始码代码之前，脑海里偏向的是第二种做法，但同时也产生了一个疑问，对于m*n阶矩阵，无论这两种的哪一种解答方式，cpu cache命中率都不高，因为不是顺序遍历，而且在已知m，n大小的情况下，矩阵中的每一对下标应该都能确定在answer中的索引值，那应该如何将下标对(x,y)进行转换成i，使得能够以顺序遍历矩阵的方式解答这道题？作为一个极容易为想法而纠结的人，也由此开始了多艰的推导之旅  

> 因为索引值的规律性，第一个想法肯定是希望能够找到一个数学方程式进行统一的下标转换，即$i=f(x,y)$，在推导好一会之后发现，螺旋的特性必然要涉及到复杂的三角函数，作为一个数学渣，最后只能不甘心的放弃了这个做法；那既然统一函数不行，那分段函数呢？通过把(x,y)分为上右和左下两部分，因为这两部分的(x,y)跟i存在线性关系，不过这个推导也放弃了，因为某层的计算需要依赖上一层的状态，这样实在太过复杂  

> 第二个想法是将矩阵中每一行进行分段处理，在手动列出几种不同形式的矩阵分布后，可以发现每一行i的规律，中间i是以递增的形式，而左右两边则是以某种差值的形式进行增加或者减少，这需要确定每一对(x,y)位于螺旋中的第几层，确定i是递增还是以差值进行增加或减少的方式，这差值也比较容易计算出来，但由于不好处理矩阵左边和下边两部分，这个想法也以失败告终  

> 虽然上面几个想法行不通（应该说实现太过复杂），但也给最终的实现方式提供了基础。具体做法是，遍历到某个位置时，首先确定当前(x,y)位于螺旋的层数，那么转换后的索引值i=外层点数+位于当前层的第几个点；每一层的外层点数都可以事先计算出来，除了最里层（差8个或7个），每一层与外层必然都是差了8个点，然后再判断(x,y)是位于右上还是左下部分，即通过分段确定坐标对位于当前层的第几个点，从而计算出i值；至于矩阵中左边和下边两部分，可以将(x,y)转换为关于x轴或y轴对称的坐标点进行判断（矩阵关于原点对称）

过程是艰辛的，结果是喜悦的，网上都是清一色的push_back或append，这的确值得花文字记录一下
#### <span id=0055>[55] 跳跃游戏</span>
题目链接：[https://leetcode-cn.com/problems/jump-game](https://leetcode-cn.com/problems/jump-game)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0055.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0055.cpp)  
运行时间：beats 88.33%  
解题思路：初始变量pathLength = nums[0]，记录可以到达最大的下标，在遍历nums过程中，如果i > pathLength，则表示i点已经不可到达，返回false，如果pathLength >= 数组最大下标，则表示数组最后一点可到达，返回true
#### <span id=0056>[56] 合并区间</span>
题目链接：[https://leetcode-cn.com/problems/merge-intervals](https://leetcode-cn.com/problems/merge-intervals)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0056.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0056.cpp)  
运行时间：beats 93.82%  
解题思路：为了使两个不重叠区间因为合并了另外一个区间而变得重叠，可以先对intervals进行排序，使得区间左端点从小到大排列，然后遍历intervals数组，合并重复区间并加入到返回列表中
#### <span id=0057>[57] 插入区间</span>
题目链接：[https://leetcode-cn.com/problems/insert-interval](https://leetcode-cn.com/problems/insert-interval)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0057.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0057.cpp)  
运行时间：beats 51.65%  
解题思路：通过newInterval找到在intervals重叠的左区间下标beginIdx，因为intervals已经顺序排列，所以从beginIdx开始找到重叠的右区间下标endIdx，在intervals上合并这些区间，并将endIdx后面的元素往前移动，对intervals进行resize之后返回intervals；需要注意一些特殊情况，比如找不到beginIdx，endIdx，或endIdx小于beginIdx等
#### <span id=0058>[58] 最后一个单词的长度</span>
题目链接：[https://leetcode-cn.com/problems/length-of-last-word](https://leetcode-cn.com/problems/length-of-last-word)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0058.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0058.cpp)  
运行时间：beats 100%  
解题思路：从后往前遍历，过滤掉空格之后开始计数，直至遇到空格结束
#### <span id=0059>[59] 螺旋矩阵-ii</span>
题目链接：[https://leetcode-cn.com/problems/spiral-matrix-ii](https://leetcode-cn.com/problems/spiral-matrix-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0059.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0059.cpp)  
运行时间：beats 100%  
解题思路：[54 螺旋矩阵](#0054)的反操作，54题为了提高cpu cache命中率，采用了顺序遍历矩阵的方式，将坐标对进行了转换，这题同理，为了提高cpu的回写效率，同样以顺序方式进行遍历，将坐标对转换成第几个数即可
#### <span id=0060>[60] 排列序列</span>
题目链接：[https://leetcode-cn.com/problems/permutation-sequence](https://leetcode-cn.com/problems/permutation-sequence)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0060.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0060.cpp)  
运行时间：beats 100%  
解题思路：从后往前计算排列数，比如n = 7，k = 9，计算到倒数第4位的时候发现4! == 24 >= 9，说明第9个排列必然是从倒数第4位开始变化出来的，而第1位到第3位保持原有序列"123"；从倒数第四位开始往后遍历，获取当前位置剩余的最小数num，当k大于下一个位置的最大排列数A时，表明当前位置为num时的总排列数小于k，此时将k - A，继续在当前位置获取下一个剩余最小数  
时间复杂度为O(N)，浏览评论的时候发现[康托展开](https://baike.baidu.com/item/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/7968428?fr=aladdin)能更加专业的解决这个问题
#### <span id=0061>[61] 旋转链表</span>
题目链接：[https://leetcode-cn.com/problems/rotate-list](https://leetcode-cn.com/problems/rotate-list)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0061.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0061.cpp)  
运行时间：beats 55.64%  
解题思路：由于旋转链表需要知道链表长度，所以需要提前遍历一次链表，为了不重复遍历，在事先遍历的同时用vector保存每一位置的结点，将k对length取余后，得到新的尾结点索引为length - 1 - k，将原头尾结点相连和将新尾结点置null后，返回新的头结点，位于索引length - k。事实证明，还不如多遍历一次链表，vector的申请空间和赋值操作同样耗时
#### <span id=0062>[62] 不同路径</span>
题目链接：[https://leetcode-cn.com/problems/unique-paths](https://leetcode-cn.com/problems/unique-paths)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0062.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0062.cpp)  
运行时间：beats 100%  
解题思路：高中的排列组合题，求某两个对角点最短路径的数目，比如m行n列的网格，从左上角的点到右下角的点，那么最短路径就只能往下或往右走，即往右走n次，往下走m次，不同的路径就是往下或往右走的时机不同，故路经数为$C_{n+m}^m$或$C_{n+m}^n$  
也可以采用动态规划求解，到达某点的最短路径数等于相邻两点（最短路径上）的最短路径数目之和，所以可以从起点开始，一步步往下求解  
题目是基于格子而不是点，但解法一致，m行n列的网格可以看作m-1行n-1列的格子组合，也可以看作，向右或向下少走一步，即$C_{n+m-2}^{m-1}$或$C_{n+m-2}^{n-1}$  
#### <span id=0063>[63] 不同路径-ii</span>
题目链接：[https://leetcode-cn.com/problems/unique-paths-ii](https://leetcode-cn.com/problems/unique-paths-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0063.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0063.cpp)  
运行时间：beats 56.13%  
解题思路：类似[62 不同路径](#0062)，由于在网格中加入了障碍物，所以上述两种方法中只能选择dp求解
#### <span id=0064>[64] 最小路径和</span>
题目链接：[https://leetcode-cn.com/problems/minimum-path-sum](https://leetcode-cn.com/problems/minimum-path-sum)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0064.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0064.cpp)  
运行时间：beats 76.92%  
解题思路：类似[63 不同路径-ii](#0063)，只是记录路径数变成记录了最小路径和
#### <span id=0065>[65] 有效数字</span>
题目链接：[https://leetcode-cn.com/problems/valid-number](https://leetcode-cn.com/problems/valid-number)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0065.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0065.cpp)  
运行时间：beats 58.06%  
解题思路：有效数字的状态不多，可以很容易的通过分支判断进行解答，但是相比之下，有限状态自动机的做法才是正途，将每一个状态都作为状态转换的枢纽，简化转换策略，思路更加清晰简洁  
参考：[确定有限状态自动机](https://leetcode.cn/problems/valid-number/solution/you-xiao-shu-zi-by-leetcode-solution-298l/) [有限状态自动机](https://zhuanlan.zhihu.com/p/400108593) [有限自动机](https://baike.baidu.com/item/%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA/8700995?fr=aladdin)
#### <span id=0066>[66] 加一</span>
题目链接：[https://leetcode-cn.com/problems/plus-one](https://leetcode-cn.com/problems/plus-one)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0066.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0066.cpp)  
运行时间：beats 100%  
解题思路：设置溢出位从后往前加，如果溢出位为0，提前结束返回，如果遍历结束后仍没有返回，则说明此时溢出位为1，往数组头部插入1返回即可
#### <span id=0067>[67] 二进制求和</span>
题目链接：[https://leetcode-cn.com/problems/add-binary](https://leetcode-cn.com/problems/add-binary)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0067.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0067.cpp)  
运行时间：beats 100%  
解题思路：设置溢出位从后往前加，先加两个字符串处于同一加法位置的部分，再单独加最长字符串的剩余部分，如果到最后仍然有溢出位，则向返回字符串头部插入'1'
#### <span id=0068>[68] 文本左右对齐</span>
题目链接：[https://leetcode-cn.com/problems/text-justification](https://leetcode-cn.com/problems/text-justification)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0068.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0068.cpp)  
运行时间：beats 100%  
解题思路：有点奇怪的题目，没有get到考察点。具体做法很简单，首先尽可能多的放置单词，即每个单词之间只留一个空格，长度超出maxWidth时结束放置，期间记录所有单词总长度length，这时候通过(maxWidth - length) / 空格集合数，计算出当前空格集合应该放置多少个空格c，因为左边空格必须多于右边空格，当c * 空格集合数 != maxWidth - length时，c自增1；循环计算，直至插完当前的所有单词；当插入的是最后一行时，特殊处理一下，即每个单词间空格数恒定为1
#### <span id=0069>[69] x-的平方根</span>
题目链接：[https://leetcode-cn.com/problems/sqrtx](https://leetcode-cn.com/problems/sqrtx)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0069.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0069.cpp)  
运行时间：beats 100%  
解题思路：采用二分法进行渐进处理，其中右边数为min(x/2+1, 46340)，其中46340是2^31-1的平方根，故所有数平方根必然不大于46340。[题解](https://leetcode.cn/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/)中的 **袖珍计算器算法** 和 **牛顿迭代** 能更巧妙的解决这道题
#### <span id=0070>[70] 爬楼梯</span>
题目链接：[https://leetcode-cn.com/problems/climbing-stairs](https://leetcode-cn.com/problems/climbing-stairs)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0070.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0070.cpp)  
运行时间：beats 100%  
解题思路：斐波那契数列问题，题目要求每次只能走1个或2个台阶，所以从第三项开始，每一项等于前面两项之和，通俗点理解就是前第2项走2个台阶到达当前台阶，前第1项走1个台阶到达当前台阶，故当前台阶走法等于前两项之和  
也可以采用排列组合的思想解答，假设走0个2阶，走法有$C_n^0$种，走1个两阶时，走法有$C_{n-1}^1$种，走2个两阶时，走法有$C_{n-2}^2$种，将所有和相加便得到第n阶台阶的走法。组合的方式适用于每次走法只能两种的情况，当存在多种走法时，计算组合数将会变得繁杂，这个时候还是斐波那契数列的解法比较简单
#### <span id=0071>[71] 简化路径</span>
题目链接：[https://leetcode-cn.com/problems/simplify-path](https://leetcode-cn.com/problems/simplify-path)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0071.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0071.cpp)  
运行时间：beats 100%  
解题思路：可以使用双向队列记录目录名，遇到'.'忽略，遇到'..'弹出尾部元素，遇到目录或文件名尾部插入，最后组装返回。但这种方式会产生过多临时变量，从而导致内存拷贝的开销，可以初始化一个返回字符串ans，遇到文件名插入，遇到'..'便回溯到上一个文件名，因为涉及到'/'的状态简单，这种方法的思路也清晰明了，可以有效的减少内存拷贝，提升效率
#### <span id=0072>[72] 编辑距离</span>
题目链接：[https://leetcode-cn.com/problems/edit-distance](https://leetcode-cn.com/problems/edit-distance)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0072.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0072.cpp)  
运行时间：beats 49.01%  
解题思路：一般题目在看完之后意识里都会有一个符合直观的大致方向，而这道两个单词转换的题目完全不符合人的直观思维，在苦思良久之后还是毫无头绪，最终还是借助了官方题解进行理解，以官方例子"horse"-->"ros"为例，要计算出它们的最小转换次数，可以先计算出下面3种情况的最小转换次数：  
1. "hors"-->"ro"，对应 **替换** 操作，这个时候需要将"horse"中剩余未转换的'e'替换成's'，假设D("hors", "ro")=k，那么D("horse", "ros")=k+1；特殊情况是，如果他们的后一个字符相同，则不需要进行替换操作，如D("horss", "ros")=k
2. "horse"-->"ro"，对应 **插入** 操作，这个时候需要往转换后的"horse"中插入's'，形成"ros"，假设D("horse", "ro")=m，那么D("horse", "ros")=m+1
3. "hors"-->"ros"，对应 **删除** 操作，这个时候需要将"horse"中剩余未转换的'e'删除，假设D("hors", "ro")=k，那么D("horse", "ros")=k+1

由上可知，当计算D(i, j)时，如果word1[i] == word2[j]，那么D(i, j) = D(i-1, j-1)，否则，D(i, j) = min(k, m, n) + 1。在评论看到一个很有意思的问题，就是word1[i] == word2[j]时，D(i, j) = D(i-1, j-1)，为什么不需要继续进行min(D(i-1, j-1), m+1, n+1)的比较，这是因为在i或j在递增过程中，D的取值要么多1，要么少1，比如D(i-1, j-1)和D(i, j-1)，D(i-1, j-1)永远小于或等于D(i, j-1) + 1  

很久之前便发现一个现象，即使是在网上写文章，写博客的作者，绝大部分对所讨论的内容其实都是一知半解，基本上都是对着教材或者前人的文章进行换汤不换药，理解要么片面，要么停留于表面，若是对某个知识点进行深入或者对知识点换一个角度进行解释，估计大部分都会不知所语。比如这道题，在看过题解之后，大部分人都知道可以采用动态规划进行解答，D(i, j)要么继承D(i-1, j-1)，要么继承D(i, j-1)，要么继承D(i-1, j)，解释彷佛也比较简单，对应替换，插入，删除操作；大多数人的理解都止于此，但这种理解是经不起考验的，因为当换一个题目的时候，往往又会陷入无从下手的困境。  

一个问题往往都会一个直观求解的过程，当问题过于复杂偏离人的直观，这个求解过程大多数时候都比较暴力，但永远不能因为得到了某种“最优解”而忽视这个暴力过程，因为最优解往往都是基于暴力解法的思路和优化，这可以看作从本质到现象；当跨过暴力解法直接得到最优解法的时候，应该反过来对暴力解法进行推导，这可以看作从现象看本质，只有摸清本质，才算真正理解并解决了问题  

回到题目，从dp的解法来看，求解D(i, j)，需要先求解D(i-1, j-1)，D(i, j-1)，D(i-1, j)，这是一个从前往后的过程（实际操作也可以从后往前，因为思路是对称的）；所以不妨直接从前往后看，对于word1中的每一个字符，要转换成word2，都要经历下面4个步骤之一：**不变，替换，删除，增加**（这个增加指的是字符前增加，假设当前转换word1[i]-->word2[j]，如果word1[i]== word2[j]，这时候对应的步骤应该是不变，如果不相等往后增加字符是没有意义的，只有往i前增加一个word2[j]才能完成转换）；所以对每一对i，j进行求解，就是当i分别选择**不变，替换，删除，增加**时的最小转换次数  

这是一个从现象看本质的过程，具体代码看链接
#### <span id=0073>[73] 矩阵置零</span>
题目链接：[https://leetcode-cn.com/problems/set-matrix-zeroes](https://leetcode-cn.com/problems/set-matrix-zeroes)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0073.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0073.cpp)  
运行时间：beats 76.12%  
解题思路：向来对空间不太感冒。设定数组row_flag，哈希表column_flag，对matrix进行第一次遍历，matrix[i][j]等于0时，将row_flag[i]置true，column_flag插入j；对matrix进行第二次遍历，当row_flag[i]为true时，整行置0，否则，遍历column_flag，将对应j的位置置0。事后发现column_flag应该改用数组存储，效率会更好一点
#### <span id=0074>[74] 搜索二维矩阵</span>
题目链接：[https://leetcode-cn.com/problems/search-a-2d-matrix](https://leetcode-cn.com/problems/search-a-2d-matrix)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0074.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0074.cpp)  
运行时间：beats 72.86%  
解题思路：遍历matrix，找到最后一个元素比target小的一维数组，然后在这个数组上进行二分查找
#### <span id=0075>[75] 颜色分类</span>
题目链接：[https://leetcode-cn.com/problems/sort-colors](https://leetcode-cn.com/problems/sort-colors)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0075.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0075.cpp)  
运行时间：beats 40.51%  
解题思路：因为只有'0 1 2'三位数字，所以不需要使用普通的排序方式对数组进行排序，可以先遍历一次数组，计算出数字总和与数字'1'的个数，然后通过总和与'1'的个数计算出其它两个数字个数，然后按照个数重写数组即可。这种方法需要对数组进行两次遍历，可以采用3指针的方式，仅需一次遍历：设置指针p0指向数组头，p2指向数组尾，pm从p0开始往p2移动，如果nums[pm]等于0，与p0所指向的数进行交换，如果nums[pm]等于2，便与p2所指向的数进行交换，直至pm大于等于p2
#### <span id=0076>[76] 最小覆盖子串</span>
题目链接：[https://leetcode-cn.com/problems/minimum-window-substring](https://leetcode-cn.com/problems/minimum-window-substring)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0076.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0076.cpp)  
运行时间：beats 66.49%  
解题思路：用哈希表T记录t中出现的字母次数，哈希表S记录已遍历s中出现t字母的次数，队列Q记录s中出现t字母的下标，同时为了方便判断遍历s的时候是否包含了t中所有字母，设置num为t中所有字母之和，对s进行遍历，如果字母c存在于t中，执行以下操作：  
1. 将字母c的坐标压入Q中，同时S[c]++
2. 如果S[c] <= T[c]，那么num -= c；如果此时num为0，说明匹配了t中所有字母，便不断弹出Q队首元素直至S中记录的队首元素对应的字母个数等于T中的记录，然后通过新的队首元素e和队尾元素刷新最短长度；最后将num加上s[e]，rec_map[s[e]]--，弹出e进行下一轮遍历寻找s[e]
#### <span id=0077>[77] 组合</span>
题目链接：[https://leetcode-cn.com/problems/combinations](https://leetcode-cn.com/problems/combinations)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0077.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0077.cpp)  
运行时间：beats 98.7%  
解题思路：初始tmp="123..k-1"，故第k个数的取值从k到n，分别插入后，然后对tmp回溯到第k-1个数，对其加一，此时第k个数取值变为k-1到n；重复上面步骤，当第k-1个数超出它的最大值时，便继续回溯到第k-2个数，重复以上步骤，直至回溯索引小于0
#### <span id=0078>[78] 子集</span>
题目链接：[https://leetcode-cn.com/problems/subsets](https://leetcode-cn.com/problems/subsets)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0078.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0078.cpp)  
运行时间：beats 100%  
解题思路：因为对于集合中每个元素，都只存在出现和不出现两种情况，故一个有n个元素的集合的所有子集数为2^n，又因为只存在两种情况，所以可以使用位计数法对子集数进行迭代以消除回溯的步骤。同样的，也可以使用递归方法进行解答，对当前的数执行以上两种情况下的操作
#### <span id=0079>[79] 单词搜索</span>
题目链接：[https://leetcode-cn.com/problems/word-search](https://leetcode-cn.com/problems/word-search)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0079.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0079.cpp)  
运行时间：beats 42.65%  
解题思路：深度优先搜索的一个非常典型的应用，以前写过的消消乐也是类似需求，在一个二维数组内进行DFS，遵循上→右→下→左的递归顺序。题目在最后的进阶提示能否用搜索剪枝的技术来优化解决方案，最开始想到的采用类似KMP算法的解决方案，对word进行运算，计算出某个字母匹配失败的时候应该回退到哪个字符，但对单词来说貌似效率不会太高；于是用另外一个数组flag进行记录，当第k个字母失配时，路径上的坐标在flag记录上各自对应的k，表示这些坐标作为第x个字符进行匹配时，不会成功。这种剪枝方案在提交的运行时间上还不如未优化的方案，这应该是跟测试用例有关，如果是类似迷宫那种存在比较多的重复集合，这种方案应该会比较理想
#### <span id=0080>[80] 删除有序数组中的重复项-ii</span>
题目链接：[https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0080.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0080.cpp)  
运行时间：beats 31.55%  
解题思路：采用双指针做法，指针forward向前移动，遇到不同的元素前停下，从指针back开始赋值最多2个forward所指向的元素，重复这些步骤直至forward移动到数组末尾。官方的双指针思路更加优雅
#### <span id=0081>[81] 搜索旋转排序数组-ii</span>
题目链接：[https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0081.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0081.cpp)  
运行时间：beats 83.22%  
解题思路：折腾了一个下午，最终还是借助了官方题解以自己的方式完成解答。当初做[搜索旋转排序数组](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/#0033)的时候，采用的是先找到旋转点，再进行二分查找的做法，但事实上可以直接在原旋转数组进行二分查找。这题类似，不同点在于存在重复元素，当存在重复元素的时候会发生nums[left] == nums[mid] == nums[right]的情况，这时候就不知道数组的旋转点位于mid的左边还是右边；受官方思路的启发，解决这种情况也很简单，不断靠拢left，right就行，直至三者不全相等
#### <span id=0082>[82] 删除排序链表中的重复元素-ii</span>
题目链接：[https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0082.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0082.cpp)  
运行时间：beats 100%  
解题思路：最开始理解错了题意，以为是去重，提交失败之后才发现是去除所有重复元素，不过按照leetcode的套路，紧挨着的第83题必然是去重，于是用原本82题的错误答案去提交了第83题...大体做法是双指针思路，设定指针slow和fast，如果fast前面没有重复元素，则slow->next = fast，slow = fast，否则忽略；为了方便头结点的操作，可以设定一个新的头结点hair指向原头结点，最后返回hair.next
#### <span id=0083>[83] 删除排序链表中的重复元素</span>
题目链接：[https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0083.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0083.cpp)  
运行时间：beats 98.52%  
解题思路：链表的去重，同样是双指针操作，没什么好说的
#### <span id=0084>[84] 柱状图中最大的矩形</span>
题目链接：[https://leetcode-cn.com/problems/largest-rectangle-in-histogram](https://leetcode-cn.com/problems/largest-rectangle-in-histogram)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0084.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0084.cpp)  
运行时间：beats 32%  
解题思路：一开始希望能以纯粹的O(n)时间复杂度解答，大体做法是遇到递增的矩形集合时刷新最大面积，但是这样相邻集合的面积难以协调计算，时间复杂度也退化到了O(n^2)。在官方题解的启发下，学会了使用单调栈来解答，事先遍历一次数组，计算出当前柱形左右两边形成最大矩形面积的边界，最后再遍历一次数组，通过两个边界相减再乘以当前高度刷新最大面积。官方题解还是比较“官方”的，但是cpp的运行时间只打败了32-51%的提交，这应该还有能继续优化的方法，看评论发现可以向数组插入一个哨兵减少分支判断，这的确精妙，但是运行时间依然不理想；继续往下翻评论，发现一个能以一次循环进行解答的方法，在单调栈处理的过程中，栈中元素左边界或者右边界已知，这时候只需要在当前循环刷新面积即可，提交之后发现运行时间打败了76%，时间的优化在于两个边界数组的创建和赋值处理；继续往下翻评论，也没能发现运行时间更理想的做法了
#### <span id=0085>[85] 最大矩形</span>
题目链接：[https://leetcode-cn.com/problems/maximal-rectangle](https://leetcode-cn.com/problems/maximal-rectangle)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0085.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0085.cpp)  
运行时间：beats 68.79%  
解题思路：[最大矩形](#0085)可以转化为[柱状图中最大的矩形](#0084)的求解，用heights数组记录matrix当前行的每一列的柱形高度，然后通过单调栈的方式求得当前最大矩形，时间复杂度为O(mn)；此题同样可以采用BF的方式进行求解，具体操作为用二维数组记录每一行每一列连续'1'的数目，假设遍历到位置(i, j)，设定高度从1开始往上生长，设定长为二维数组记录的最小值，将高度乘以长刷新最大矩形面积，时间复杂度为O(m^2n)
#### <span id=0086>[86] 分隔链表</span>
题目链接：[https://leetcode-cn.com/problems/partition-list](https://leetcode-cn.com/problems/partition-list)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0086.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0086.cpp)  
运行时间：beats 89.7%  
解题思路：双指针策略，fast往后遍历，遇到比x小的扔到slow后面，同时slow往后移
