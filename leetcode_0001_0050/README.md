# leetcode_0001_0050
|order|question|cpp link|
|:-|:-|:-|
|[0001](#0001)|[两数之和](#0001)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0001.cpp)|
|[0002](#0002)|[两数相加](#0002)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0002.cpp)|
|[0003](#0003)|[无重复字符的最长子串](#0003)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0003.cpp)|
|[0004](#0004)|[寻找两个正序数组的中位数](#0004)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0004.cpp)|
|[0005](#0005)|[最长回文子串](#0005)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0005.cpp)|
|[0006](#0006)|[z-字形变换](#0006)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0006.cpp)|
|[0007](#0007)|[整数反转](#0007)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0007.cpp)|
|[0008](#0008)|[字符串转换整数-atoi](#0008)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0008.cpp)|
|[0009](#0009)|[回文数](#0009)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0009.cpp)|
|[0010](#0010)|[正则表达式匹配](#0010)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0010.cpp)|
|[0011](#0011)|[盛最多水的容器](#0011)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0011.cpp)|
|[0012](#0012)|[整数转罗马数字](#0012)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0012.cpp)|
|[0013](#0013)|[罗马数字转整数](#0013)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0013.cpp)|
|[0014](#0014)|[最长公共前缀](#0014)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0014.cpp)|
|[0015](#0015)|[三数之和](#0015)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0015.cpp)|
|[0016](#0016)|[最接近的三数之和](#0016)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0016.cpp)|
|[0017](#0017)|[电话号码的字母组合](#0017)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0017.cpp)|
|[0018](#0018)|[四数之和](#0018)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0018.cpp)|
|[0019](#0019)|[删除链表的倒数第-n-个结点](#0019)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0019.cpp)|
|[0020](#0020)|[有效的括号](#0020)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0020.cpp)|
|[0021](#0021)|[合并两个有序链表](#0021)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0021.cpp)|
|[0022](#0022)|[括号生成](#0022)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0022.cpp)|
|[0023](#0023)|[合并k个升序链表](#0023)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0023.cpp)|
|[0024](#0024)|[两两交换链表中的节点](#0024)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0024.cpp)|
|[0025](#0025)|[k-个一组翻转链表](#0025)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0025.cpp)|
|[0026](#0026)|[删除有序数组中的重复项](#0026)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0026.cpp)|
|[0027](#0027)|[移除元素](#0027)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0027.cpp)|
|[0028](#0028)|[实现-str-str](#0028)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0028.cpp)|
|[0029](#0029)|[两数相除](#0029)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0029.cpp)|
|[0030](#0030)|[串联所有单词的子串](#0030)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0030.cpp)|
|[0031](#0031)|[下一个排列](#0031)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0031.cpp)|
|[0032](#0032)|[最长有效括号](#0032)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0032.cpp)|
|[0033](#0033)|[搜索旋转排序数组](#0033)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0033.cpp)|
|[0034](#0034)|[在排序数组中查找元素的第一个和最后一个位置](#0034)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0034.cpp)|
|[0035](#0035)|[搜索插入位置](#0035)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0035.cpp)|
|[0036](#0036)|[有效的数独](#0036)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0036.cpp)|
|[0037](#0037)|[解数独](#0037)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0037.cpp)|
|[0038](#0038)|[外观数列](#0038)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0038.cpp)|
|[0039](#0039)|[组合总和](#0039)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0039.cpp)|
|[0040](#0040)|[组合总和-ii](#0040)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0040.cpp)|
|[0041](#0041)|[缺失的第一个正数](#0041)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0041.cpp)|
|[0042](#0042)|[接雨水](#0042)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0042.cpp)|
|[0043](#0043)|[字符串相乘](#0043)|[cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0043.cpp)|

#### <span id=0001>[1] 两数之和</span>
题目链接：[https://leetcode-cn.com/problems/two-sum](https://leetcode-cn.com/problems/two-sum)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0001.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0001.cpp)  
运行时间：beats 93%  
解题思路：这题思路比较明显，用哈希表存储，key存储值，value存储索引，遍历的时候判断差值是否也在哈希表中，是则返回索引；但具体实现的时候先遍历了一次数组，把值加入到哈希表中，再进行差值判断，技巧性较差。在思路正确的情况下，实现好坏往往都是取决于实现技巧
#### <span id=0002>[2] 两数相加</span>
题目链接：[https://leetcode-cn.com/problems/add-two-numbers](https://leetcode-cn.com/problems/add-two-numbers)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0002.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0002.cpp)  
运行时间：beats 77%  
解题思路：链表的大数相加，设定一个初始为0的溢出位，每次循环依次与对应链表位相加，直至加完所有位数和溢出位为0即可
#### <span id=0003>[3] 无重复字符的最长子串</span>
题目链接：[https://leetcode-cn.com/problems/longest-substring-without-repeating-characters](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0003.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0003.cpp)  
运行时间：beats 69%  
解题思路：解答方式不是最优解，用哈希表记录已遍历的字符和对应下标，遇到新字符时若哈希表已经存在对应字符，则计算当前下标与基准下标（初始为0）的差值，如果比已记录的最长长度大，则更新最长长度，然后哈希表弹出基准下标到重复字符下标之间的字符，最后更新基准下标然后进入新的循环；最优解是用容量为256的数组记录遍历字符时出现的最大下标，然后设定一个重复下标I，遍历字符时若当前字符记录的下标大于I，则说明当前字符重复，更新I和最长记录长度；其实当前方法可以借鉴最优解答法，它们最大的不同除了记录的数据结构不一样，就在于当前解答方法遇到重复字符时弹出了重复字符之前的所有字符，这是一个无用功，因为基准下标已记录了重复字符的下标，所以只需在哈希表遇到重复字符时多加一个是否大于基准坐标的判断即可
#### <span id=0004>[4] 寻找两个正序数组的中位数</span>
题目链接：[https://leetcode-cn.com/problems/median-of-two-sorted-arrays](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0004.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0004.cpp)  
运行时间：beats 60%  
解题思路：苦思一个小时，结果第一道hard就翻车；题目限定了时间复杂度为O(log(m+n))，所以不能开辟额外空间对数组进行排序；最终还是看了最多投票答案，思路是计算出中位数偏移位置f之后，分别向两个数组分摊这个偏移，假设为f1、f2，因为两个数组是升序排列，所以如果nums1[f1]小于nums2[f2]，那nums1数组中前f1位就可以确定小于中位数，记录这个f1，并将f-f1，重复判断，直至f等于1（如果f1或f2达到对应数组长度，返回另一个数组剩余f的偏移即可）；题解是递归实现，思路明确之后非递归的实现也比较容易写，本题解答便是同样思路的非递归实现；这题可以进一步抽象，求n个数组，总长度为N的中位数，同样可以按照这个思路求解，时间复杂度为O(log_n N)
#### <span id=0005>[5] 最长回文子串</span>
题目链接：[https://leetcode-cn.com/problems/longest-palindromic-substring](https://leetcode-cn.com/problems/longest-palindromic-substring)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0005.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0005.cpp)  
运行时间：beats 83%  
解题思路：设定一个基准点，然后判断两边字符是否相等，刷新最长回文子串；如果左边字符与基准字符相等，再执行同样的操作，时间复杂度为O(n^2)，可以优化的点是当最长回文子串长度大于基准点与最尾字符距离差值的两倍时，可以提前跳出循环，结束判断
#### <span id=0006>[6] z-字形变换</span>
题目链接：[https://leetcode-cn.com/problems/zigzag-conversion](https://leetcode-cn.com/problems/zigzag-conversion)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0006.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0006.cpp)  
运行时间：beats 96%  
解题思路：最直观的方法就是设定个数与输入行数相等的字符串数组，对原字符串进行遍历的时候根据下标将字符赋值到不同的字符串数组中，最后拼接返回，时间复杂度为O(n)，不过这种方法部分字符在最后进行了无意义拷贝。可以对Z-字形排列进行找规律，比如输入行数为5，那么第1行和第5行字符每次步进长度为（5-1）\*2=8，中间第2行每次步进长度分别为（5-2）\*2=6，8-6=2循环...根据这种规律，设定一个新字符串并对行数进行遍历，将每一行的字符根据步进长度依次复制到新字符串中，最后返回；时间复杂度与第一种方法一致，但是部分字符却少了一次内存拷贝
#### <span id=0007>[7] 整数反转</span>
题目链接：[https://leetcode-cn.com/problems/reverse-integer](https://leetcode-cn.com/problems/reverse-integer)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0007.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0007.cpp)  
运行时间：beats 42.21%  
解题思路：一开始以为是与或非的位运算问题，想了半天感觉没方案就采用了循环除法，结果runtime只打败了42.21%的提交，去看题解结果思路都是一样的，难道是因为部分提交直接标明了INT_MAN和INT_MIN的前后部分数值导致了runtime的差异？于是把代码里面对INT_MAN和INT_MIN的计算去掉，写定了具体数值，再次submit，runtime打败了100%的提交...
#### <span id=0008>[8] 字符串转换整数-atoi</span>
题目链接：[https://leetcode-cn.com/problems/string-to-integer-atoi](https://leetcode-cn.com/problems/string-to-integer-atoi)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0008.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0008.cpp)  
运行时间：beats 100%  
解题思路：过滤掉前置空格后判断符号位，设置factor为1或者-1，将factor乘以每次读取的字符与'0'的ASCII码差值，然后累加，直至字符串结束或者遇到非数字字符，累加后若累加数大于等于INT_MAX，结束返回INT_MAX，INT_MIN同理
#### <span id=0009>[9] 回文数</span>
题目链接：[https://leetcode-cn.com/problems/palindrome-number](https://leetcode-cn.com/problems/palindrome-number)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0009.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0009.cpp)  
运行时间：beats 95%  
解题思路：将输入整数拆分成前后两部分判断是否相等，后部分通过累加累乘反转，最后判断前后两部分是否相等或去掉中间数之后是否相等即可；值得注意的是形如122100这种最末尾一位有0的，需要提前判断返回false，不然按照这种思路会返回true
#### <span id=0010>[10] 正则表达式匹配</span>
题目链接：[https://leetcode-cn.com/problems/regular-expression-matching](https://leetcode-cn.com/problems/regular-expression-matching)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0010.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0010.cpp)  
运行时间：beats 9.96%  
解题思路：runtime打败了9.69%的提交...解答采用了递归的方法，对比了一下官网递归题解的思路，发现有许多值得优化的地方，先mark一下自己的思路：题目中的正则匹配可以分为两种，一种是带\*匹配，一种是单个字符匹配。单个字符匹配比较好处理，步进判断即可；带\*匹配是匹配0个或多个，当遇到带\*匹配时，需要递归判断s中的剩余字符（已匹配索引一步步往后移）和p中剩余匹配字符，当成功匹配一次时返回true，如果都没成功匹配返回false  

官方的递归思路与上述思路大体一致，主要差别体现在实现技巧上，比如官解最开始的返回点是判断p是否为空，是则返回s是否为空，但上述解答中传入p就不允许为空，这就使代码里面会p的长度进行较多的判断，逻辑也变得冗余，代码不够简洁清晰  

另外一种经典解法就是DP求解，设定数组dp[i][j]，表示s中的前i个字符能够被p的前j个字符匹配，i从0开始，迭代计算当前i与j（0-p的长度）能否匹配；在官方DP解答中，为了使状态能够进行顺利迁移，对i和j进行了特别处理，使p对空字符串进行了一次正则匹配，但这似乎也使大部分人的理解直接撞墙，也包括我自己；在真正搞懂DP的思路之后，可以对官方题解进行思路优化。使i，j从0开始，不大于对应字符串长度，在明确初始状态之后，还需要明确i=0，j≠0时的状态迁移，这也是跟目前其他题解最大的不同，具体看代码；时间复杂度O(mn)，与递归解法一致，但多次提交的runtime都达到了0ms
#### <span id=0011>[11] 盛最多水的容器</span>
题目链接：[https://leetcode-cn.com/problems/container-with-most-water](https://leetcode-cn.com/problems/container-with-most-water)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0011.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0011.cpp)  
运行时间：beats 53%  
解题思路：从两边向中间靠拢计算，取最小高度\*宽度并刷新最大面积，如果左边等于最小高度，左边向中间靠拢，否则右边向中间靠拢；时间复杂度O(n)，原以为达到了最优解法，结果还是有可以优化的地方：向中间靠拢时判断新坐标对应的值是否小于等于最小高度，是则继续执行靠拢操作跳过不必要的面积计算
#### <span id=0012>[12] 整数转罗马数字</span>
题目链接：[https://leetcode-cn.com/problems/integer-to-roman](https://leetcode-cn.com/problems/integer-to-roman)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0012.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0012.cpp)  
运行时间：beats 49%  
解题思路：提交之后看到runtime不够理想点开最多投票答案，好家伙，直接用列表保存了每一位对应的罗马数字，这也让我想起以前写过获取位图第一个为0的高位索引的代码，采用的也是类似的方法，256个char保存了出现0的最高位索引。当前思路：分析得知，当出现4，5，9时需要特殊处理添加左边罗马数字，然后剩下高位小于4的数，再循环添加，所以可以写成两个函数依次调用，即传入高位因子和对应罗马数字分别处理这两种情况
#### <span id=0013>[13] 罗马数字转整数</span>
题目链接：[https://leetcode-cn.com/problems/roman-to-integer](https://leetcode-cn.com/problems/roman-to-integer)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0013.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0013.cpp)  
运行时间：beats 81%  
解题思路：类似于上一道题，可以用哈希表保存每个罗马字符对应的数值；对罗马字符串进行遍历，累加每一位数，特殊的情况是，遇到紧挨的罗马数字且左边比右边小时，需要减掉左边数的两倍
#### <span id=0014>[14] 最长公共前缀</span>
题目链接：[https://leetcode-cn.com/problems/longest-common-prefix](https://leetcode-cn.com/problems/longest-common-prefix)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0014.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0014.cpp)  
运行时间：beats 100%  
解题思路：初始返回字符串r为strs第一个字符串，最小公共前缀长度m为strs第一个字符串长度，对strs剩余字符串进行遍历，刷新m的长度，并迭代判断r与当前遍历字符串的前m个字符是否相等，不相等时刷新m长度并进入下一次循环，时间复杂度为O(mn)。而在官方解答中，先对strs进行排序，再比较第一个和最后一个字符，但string的排序需要逐字符对比，排序复杂度不会低于O(nmlogm)，再加上排序过程存在不必要的内存拷贝，所以总体效率远不如上述做法
#### <span id=0015>[15] 三数之和</span>
题目链接：[https://leetcode-cn.com/problems/3sum](https://leetcode-cn.com/problems/3sum)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0015.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0015.cpp)  
运行时间：beats 25.69%  
解题思路：先对数组进行升序排序，反向遍历数组，将正数添加进map中（不用哈希表是因为循环时遇到比中间数小的右边数时可以直接break）并记录最小正数下标；对i，j进行双重遍历，i从0开始，不大于最小正数下标（不算3个0的情况，必然会有一个负数），j从i+1开始，不大于数组长度-1；通过nums[i]+nums[j]计算出另外一个数a，如果a\<nums[j]，跳出循环；如果a==nums[j]，通过判断map中记录a的个数是否记录结果，跳出循环；如果a\>nums[j]且map中能查找到a，记录结果；最后还需要特殊处理一下存在3个0的情况；时间复杂度为O(n^2)  

官方的双指针（下标）解法效率更高，同样的先对数组进行升序排序，指针i从数组左边出发，指针k从数组右边出发，指针j从i的右边出发，通过nums[i]+nums[j]计算出另外一个数a，如果a比nums[k]小，则k递减，因为-a已经是当前最小数，比a大的数已经可以舍弃判断
#### <span id=0016>[16] 最接近的三数之和</span>
题目链接：[https://leetcode-cn.com/problems/3sum-closest](https://leetcode-cn.com/problems/3sum-closest)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0016.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0016.cpp)  
运行时间：beats 49.29%  
解题思路：思路类似上一题，采用排序+多指针解法。设3个指针left，middle，right；left从0开始，middle从left+1开始，right从数组末尾开始，迭代往数组中间靠拢；当left固定，三个数的sum\>target时right--，即向middle靠拢；sum\<target时middle++，向right靠拢；sum==target时直接返回即可；当进行新一轮的left迭代时，right需要重置，开始的几次提交也是不注意这个点导致了WA，right向middle靠拢是因为前两个数和不变的情况下总值sum依然比target大，而进行新的一轮迭代时，前两数之和重新计算，不一定会大于上一轮的最大值，所以这时候就需要重置right
#### <span id=0017>[17] 电话号码的字母组合</span>
题目链接：[https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0017.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0017.cpp)  
运行时间：beats 100%  
解题思路：看完题目之后想起了之前写[有向图](https://github.com/ccencon/structdata#DirectedGraph)输出所有拓扑序列和所有关键路径的代码，这里也可以采用同样的算法。首先初始化一个数组v，记录每个位置字符对应字符串的下一个遍历位置，初始化回溯索引traceIdx=0；递增traceIdx，将digits对应traceIdx的字符所对应v所记录遍历位置的字符添加到临时字符串tmp中，递增完traceIdx后，tmp将会是一个新的字符串；然后回溯traceIdx，当v中对应traceIdx的记录已经等于对应字符串的长度时继续回溯同时清零v中对应记录；当traceIdx>=0时继续递增traceIdx的步骤；时间复杂度近似为O(3^n)。大部分题解采用的是基于递归的DFS遍历，时间复杂度一致，但是实际效率上会差上不少；在上面提交中，采用了哈希表记录每个数字对应的字符串，可以改用顺序数组记录，毕竟只有两个空余位置，这是一个值得优化的点
#### <span id=0018>[18] 四数之和</span>
题目链接：[https://leetcode-cn.com/problems/4sum](https://leetcode-cn.com/problems/4sum)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0018.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0018.cpp)  
运行时间：beats 76.97%  
解题思路：三数和的进阶版，后面是否还有n数和？思路类似第15题的三数之和，先固定两个坐标，设定两个指针l，r分别从数组前后往中间靠拢，总和sum\>target时，r--；sum\<target时，l++；相等时四数符合题意；值得注意的是，相等时还需继续移动l，r判断，因为中间可能还存在满足条件的其它两数
#### <span id=0019>[19] 删除链表的倒数第-n-个结点</span>
题目链接：[https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0019.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0019.cpp)  
运行时间：beats 77.58%  
解题思路：顺序遍历链表，并记录当前遍历长度的倒数第n+1个结点node；遍历完成后如果存在倒数n+1个结点，则node=node->next->next，如果头结点恰好是第n个结点，则head=head->next；最后返回head即可
#### <span id=0020>[20] 有效的括号</span>
题目链接：[https://leetcode-cn.com/problems/valid-parentheses](https://leetcode-cn.com/problems/valid-parentheses)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0020.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0020.cpp)  
运行时间：beats 100%  
解题思路：用栈记录左括号，遇到右括号时出栈，如果栈为空或者出战的左括号跟当前右括号对应不上则返回false；最后判断是否出栈了所有左括号并返回结果
#### <span id=0021>[21] 合并两个有序链表</span>
题目链接：[https://leetcode-cn.com/problems/merge-two-sorted-lists](https://leetcode-cn.com/problems/merge-two-sorted-lists)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0021.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0021.cpp)  
运行时间：beats 100%  
解题思路：利用迭代的方法，不断的将一张链表的结点合并到另外一张；合并的时候记录当前的合并位置，因为两张链表都是升序排序，下一个合并结点必然大于等于当前所记录的位置结点；特殊的情况是，合并第一个结点时，可能会小于记录结点，这时候往头部插入即可
#### <span id=0022>[22] 括号生成</span>
题目链接：[https://leetcode-cn.com/problems/generate-parentheses](https://leetcode-cn.com/problems/generate-parentheses)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0022.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0022.cpp)  
运行时间：beats 100%  
解题思路：所看到的题解都是基于递归的DFS或者回溯，部分是DP；对这类回溯类型的题目，如果理解透彻，应该很容易就写出非递归的回溯解法，这应该也是效率最高的。思路类似[电话号码的字母组合](#0017)，因为字符串第0位必为'('，所以初始回溯索引traceIdx为1，剩余左括号数为left_count=n-1，字符串tmp="("；使traceIdx递增进行迭代，迭代过程中，如果left_count>0，tmp插入'('，同时left_count自减1，也就是优先插入'('，否则插入')'；迭代完成后，tmp将会是新的满足题意的字符串；然后回溯traceIdx，遇到')'时left_count自增1，如果traceIdx往后的剩余空间可以容纳下left_count数量的'('和')'，那么将此位置的'('设置为')'，同时对traceIdx的回溯停止，转到traceIdx的迭代步骤，直至traceIdx小于1；总体时间复杂度近似O(2^n)
#### <span id=0023>[23] 合并k个升序链表</span>
题目链接：[https://leetcode-cn.com/problems/merge-k-sorted-lists](https://leetcode-cn.com/problems/merge-k-sorted-lists)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0023.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0023.cpp)  
运行时间：beats 15.93%  
解题思路：看到运行时间瞬间懵逼，采用的是[合并两个有序链表](#0021)的解法，虽然隐隐感觉还有可以优化的点，但觉得应该也不会太差...看了投票答案，采用的是分治的递归算法，但时间复杂度都近似O(mn*log_2 m)，不至于差别这么大吧，看了官方题解，优先队列！！！...捂脸...
#### <span id=0024>[24] 两两交换链表中的节点</span>
题目链接：[https://leetcode-cn.com/problems/swap-nodes-in-pairs](https://leetcode-cn.com/problems/swap-nodes-in-pairs)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0024.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0024.cpp)  
运行时间：beats 100%  
解题思路：没啥好说的，在一些时候代码简洁短小和易读易懂确实不可兼得
#### <span id=0025>[25] k-个一组翻转链表</span>
题目链接：[https://leetcode-cn.com/problems/reverse-nodes-in-k-group](https://leetcode-cn.com/problems/reverse-nodes-in-k-group)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0025.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0025.cpp)  
运行时间：beats 45.51%  
解题思路：如果不考虑空间复杂度，用栈实现最清晰明了，时间复杂度都为O(n)；考虑到O(1)的空间复杂度，每次遍历够k个结点时记录最左和最右两个结点，然后不断将最左边的结点依次插入到最右边结点后面；这题的难点应该在于如何对头结点进行优雅的处理，因为链表头没有头结点，这样会使得循环体内代码难以处理，而解决这个问题只需创建一个新的头结点即可
#### <span id=0026>[26] 删除有序数组中的重复项</span>
题目链接：[https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0026.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0026.cpp)  
运行时间：beats 82.12%  
解题思路：设定基准索引k=0，遍历索引i从1开始，当nums[i]≠nums[k]时，nums[++k]=nums[i]，最后返回k+1
#### <span id=0027>[27] 移除元素</span>
题目链接：[https://leetcode-cn.com/problems/remove-element](https://leetcode-cn.com/problems/remove-element)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0027.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0027.cpp)  
运行时间：beats 100%  
解题思路：跟上一题一样，也是双指针思路，大体做法是设定索引k，last分别从数组两边开始，当nums[k]==val时，交换nums[k]和nums[last]，最后返回k
#### <span id=0028>[28] 实现-str-str</span>
题目链接：[https://leetcode-cn.com/problems/implement-strstr](https://leetcode-cn.com/problems/implement-strstr)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0028.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0028.cpp)  
运行时间：beats 100%  
解题思路：还记得大学时在老师讲解KMP算法的时候听得实在是云里雾里，似懂非懂，一直抓不住彻底理解的要义，不过对于这个算法后来感觉也挺自豪的，因为在尝试多次按照教材的思路彻底理解失败之后，干脆以自己的方式进行推演，最终也找到了KMP的另外一种实现形式，这种实现形式也是在不回溯主串的前提下回溯模式串，但对于模式串的回溯却有着质的区别，下面先记录一下个人实现方式，再记录对传统KMP算法的理解  

要理解KMP算法，首先要理解为什么不用回溯主串，教材上的说明直接是对模式串进行讲解，尝试找到每个匹配字符与模式串前k个字符相等的前置字符串，但这种方式明显不够直观清晰；令模式串$t=t_0t_1t_2t_3t_4t_5t_6$，主串$s=s_0s_1s_2s_3s_4s_5s_6···s_n$，其中$t_0-t_5=s_0-s_5$，$t_6≠s_6$，那么在匹配过程中比较到下标6的时候就需要对主串或模式串进行回溯，因为现在讨论的是为什么不用对主串进行回溯，所以可以先假设需要对主串进行回溯到某一个位置  

+ 假设需要回溯到$s_1$，那么需要有$s_1s_2s_3s_4s_5=t_0t_1t_2t_3t_4$，因为如果这两部分不相等，回溯到$s_1$没有意义，又因为已匹配结果$t_0-t_5=s_0-s_5$，所以当$t_0=s_0=t_1=s_1=t_2=s_2=···=t_5=s_5$时需要回溯到$s_1$，举个例子：$t="aaaaaax"$，$s="aaaaaay···s_n"$
+ 假设需要回溯到$s_2$，同理需要有$s_2s_3s_4s_5=t_0t_1t_2t_3$，又因为已匹配结果$t_0-t_5=s_0-s_5$，所以当$s_0=t_0=s_2=t_2=s_4=t_4$，$s_1=t_1=s_3=t_3=s_5=t_5$，$s_0≠s_1$时需要回溯到$s_2$，举个例子：$t="abababx"$，$s="abababy···s_n"$
+ 假设需要回溯到$s_3$，同理需要有$t_0t_1t_2=s_3s_4s_5$，又因为已匹配结果$t_0-t_5=s_0-s_5$，所以当$s_0=t_0=s_3=t_3$，$s_1=t_1=s_4=t_4$，$s_2=t_2=s_5=t_5$，$s_0,s_1,s_3$不同时相等的时候需要回溯到$s_3$，举个例子：$t="abcabcx"$，$s="abcabcy···s_n"$
+ ···

通过观察可以发现，当字符$y$失配时，如果需要回溯到$s_1$，需要$s_0$周期性出现直至字符$y$；如果需要回溯到$s_2$，需要$s_0s_1$周期性出现直至字符$y$；如果需要回溯到$s_3$，需要$s_0s_1s_2$周期性出现直至字符$y$；所以可以计算出每个字符出现的最小周期（比如$t$=aaaa，所有a的最小周期为1；$t$=ababab，第一个a的最小周期为1，第二和第三个a的最小周期为2；$t$=abcabcabc，第一个a的最小周期为1，第二和第三个a的最小周期为3，第一个b最小周期为2，第二和第三个b最小周期为3），当出现失配字符$y$时，只需获取它前一个字符的最小周期T，然后将此时主串的初始匹配位置往后移动一个最小周期（假设此时位置为$s_t$），再与模式串进行重新比较；又因为其周期性，$[s_t,y)=[t_0,t_n)$，即$[s_t,y)$可以匹配长度相等的$[t_0,t_n)$，所以$[s_t,y)$与$[t_0,t_n)$进行再次比较是没有意义的，这时候只需将$y$与$t_n$进行比较，也就是说，不用对$s$进行回溯，直接比较$y$与$t_n$和它们后面的字符即可  

因为$s$中$y$与$t$中$x$前面的字符相等，且$s$可以从任意配置开始匹配，而$t$只能从第0位开始匹配，所以求最小周期，其实就是求$t$中各字符按照某个**最短序列**重复出现的**周期**，步骤如下：  

1. 因为$t$的第0位字符周期恒为1，故初始最小周期T = 1，周期数组tempus[0] = 1
2. 设定索引i = 1，i < t.size()，对i进行递增迭代执行以下逻辑

    + 令idx = i % T，即idx为当前i对应t中第一个周期的下标，判断m[i] == m[idx]，如果相等，则tempus[i] = T，否则转到下面步骤
    + 因为m[i] != m[idx]，所以需要将周期T进行递增迭代，并将位于i和（i前面的且与i位于同一周期的索引位）的字符与$t$的前面的字符做比较，如果全部相等，则tempus[i] = T；如果周期T递增迭代来到了当前i的位置，则T = i + 1，tempus[i] = T

上述步骤采用取余法求得当前字符对应第一个周期的下标，也可以改用双指针的实现方式；而传统KMP算法同样需要求得$t$的一个数组next，但next记录的不是每个字符按照某个序列出现的最小周期，而是当发生失配时，$t$应该回溯到的位置，所以上面的做法可以看作是对传统KMP算法的一个过渡，求next数组，本质就是求$t$每一个字符及它所有前置的字符尽可能长的与$t$开头几个字符匹配，这样当某个下标的字符失配时，$t$便可直接回溯到next记录的下标重新比较，具体步骤如下：

1. 初始j = 0（记录可匹配的最长字符串下标），i = 2（trick，迭代时比较的是t[i - 1]和t[j]，在strStr函数过程中如果失配，t回溯的下标取next[j]而不是next[j - 1]），数组next[1] = 0；对i进行迭代执行步骤2和3
2. 如果t[i - 1] == t[j]，则表明$[t_0,t_j]==[t_{i-1-j},t_{i-1}]$，执行j++，并设置next[i] = j，也就是说当下标i的字符失配时，将$t$回溯到j的位置继续与主串的失配位置进行比较
3. 如果t[i - 1] != t[j]，则表明$[t_0,t_j]!=[t_{i-1-j},t_{i-1}]$，这时候next[i]就不能等于j+1了；但从上一轮的匹配结果来看，也就是$[t_0,t_{next[j]}]==[t_{i-2-next[j]},t_{i-2}]$，所以将j进行回溯，j = next[j]，重复执行步骤2和3
#### <span id=0029>[29] 两数相除</span>
题目链接：[https://leetcode-cn.com/problems/divide-two-integers](https://leetcode-cn.com/problems/divide-two-integers)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0029.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0029.cpp)  
运行时间：beats 48.64%  
解题思路：这是目前为止做的最难受一题，不知道leetcode官方采用的什么版本cpp编译器，居然不支持负数的算术移位。具体思路是，因为商是一个具体整数，而一个整数从二进制看则是由0个或多个不同的2的n次方幂相加得到，所以设定i从31开始，不小于0，迭代执行以下逻辑：如果dividend>>i \<= divisor，则说明dividend包含的divisor大于等于2^i，所以将dividend减去2^i个divisor，并将quotient叠加上2^i，最后返回。这题的难点在于对溢出和符号位的细节处理，折腾了差不多一个下午，真是难受
#### <span id=0030>[30] 串联所有单词的子串</span>
题目链接：[https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0030.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0030.cpp)  
运行时间：beats 91.35%  
解题思路：开始还理解错了题意，以为是返回words中单词组合成子串在s中的各自位置，测试之后才发现是返回所有子串的起始位置，不过做法也差不了多少。具体思路：滑动窗口，哈希表t保存words中每个单词出现的次数，哈希表t'保存对应单词已使用次数；然后向右滑动窗口，即截取s中一个长度单位字符，判断是否在t中，如果不在，窗口左边滑动到当前位置，清空t'；如果存在，则记录t'，如果已经匹配了所有单词，记录当前窗口左边位置；当t'中某个单词使用次数达到上限，则每次移动左窗口一个长度，并减少相应单词在t'中记录。
#### <span id=0031>[31] 下一个排列</span>
题目链接：[https://leetcode-cn.com/problems/next-permutation](https://leetcode-cn.com/problems/next-permutation)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0031.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0031.cpp)  
运行时间：beats 100%  
解题思路：解答这类题最快的方法就是找规律，首先设定一个数组，列出它排列的几种情况，可以很容易发现，当末尾某个数及它后面的序列不是降序排列时，找到这个序列比它大且数值最接近它的一个整数，将两者交换，最后再对这个序列进行反转变为升序即可
#### <span id=0032>[32] 最长有效括号</span>
题目链接：[https://leetcode-cn.com/problems/longest-valid-parentheses](https://leetcode-cn.com/problems/longest-valid-parentheses)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0032.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0032.cpp)  
运行时间：beats 100%  
解题思路：设置一个记录左括号数变量count，遇到左括号时count++，遇到右括号时count--，当count为0时便刷新最大长度；但这样会有一个问题，当s中左括号比右括号多的时候，会发生长度为0的情况，因为count减少不到0，比如s="()((()()"，这时候便使count变为记录右括号数，以同样的逻辑重新反向遍历s即可  

也可以采用动态规划求解，初始dp数组为0，设定i从1开始遍历s，当s[i] == '('时，跳过，因为当前'('必然是匹配后面的')'；当s[i] == ')'时，如果s[i - 1] == '('，则说明这两个括号相互配对，有dp[i] = dp[i - 2] + 2；如果s[i - 1] == ')'，且s[i - dp[i - 1] - 1] == '('，则说明s[i]与s[i - dp[i - 1] - 1]相互配对，这时候有dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]
#### <span id=0033>[33] 搜索旋转排序数组</span>
题目链接：[https://leetcode-cn.com/problems/search-in-rotated-sorted-array](https://leetcode-cn.com/problems/search-in-rotated-sorted-array)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0033.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0033.cpp)  
运行时间：beats 69.49%  
解题思路：先遍历一次数组找到旋转点设置left和right，再对left和right进行二分查找；而在官方题解中省略事先遍历的操作，因为可以在二分查找的过程中通过各种判断设置left和right，方法更加高效
#### <span id=0034>[34] 在排序数组中查找元素的第一个和最后一个位置</span>
题目链接：[https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0034.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0034.cpp)  
运行时间：beats 58.33%  
解题思路：比较直观的做法是利用一次二分法找到target，然后分别向左和向右做延伸，直至找到两个下标，在一般情况中，相同的target不会占数组的绝大部分，所以这应该是实际效率最高的一种做法；但算法题应该不喜欢这种理论上退化到O(n)的做法，那便通过两次二分查找解决吧
#### <span id=0035>[35] 搜索插入位置</span>
题目链接：[https://leetcode-cn.com/problems/search-insert-position](https://leetcode-cn.com/problems/search-insert-position)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0035.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0035.cpp)  
运行时间：beats 74.01%  
解题思路：也是二分查找的思想，思路比较简单，但还是在返回值的处理上花费了一点时间
#### <span id=0036>[36] 有效的数独</span>
题目链接：[https://leetcode-cn.com/problems/valid-sudoku](https://leetcode-cn.com/problems/valid-sudoku)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0036.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0036.cpp)  
运行时间：beats 77.66%  
解题思路：设定几个容器保存每一行，每一列，每一个九宫格的字符数，数量超出1时返回false；因为数独的数字是1-9，所以容器可以采用数组替代哈希表
#### <span id=0037>[37] 解数独</span>
题目链接：[https://leetcode-cn.com/problems/sudoku-solver](https://leetcode-cn.com/problems/sudoku-solver)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0037.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0037.cpp)  
运行时间：beats 58.87%  
解题思路：断断续续的四天时间终于AC了，期间陷入了不少的思维误区，所幸最终都理清了思路。设定一个二维数组bits[9][9]，通过比特位记录每一个格子剩余可选的数字；对board数组进行第一次遍历：  
+ 遇到数字时将当前格子的bits置0，并将对应行，对应列，对应九宫格所有格子对此数字相应的bit位置0，在此过程中，如果遇到'.'，执行下面步骤
+ 如果遇到'.'，则判断当前格子所剩可选数字数目是否为1，是的话填入唯一可选数字，对此格子转到上一步骤，进行递归调用  

当时做到这个步骤的时候，以为已经得到了正确的解，在默认测试用例通过后，满怀信心的去提交，结果第二个测试用例就解答错误，迷糊了好一会才发现还有多个格子剩余可选数全都大于1的情况。这时候的做法应该是对所有位置递归代入每一个可能的数，当某个位置没有可选数时表明上一步或几步代入的数不合法，这时候应该回溯到上一步，换一个数进行代入。而在这里受到惯性思维影响，对要递归的下一个位置采用了类似第一次遍历确定唯一数的做法，对当前行，当前列，当前九宫格的所有格子在当前步骤内全都进行递归，而这种做法弊端就是当某个格子发生匹配错误时，对之前已经递归匹配成功的格子的状态将难以恢复，脑海里隐约中彷佛有一些解决方法，但都因为实现起来太过复杂放弃了，这也是这次花费这么多时间的原因。比较清晰的做法应该是保存这些可选数大于1的格子，在对第一个格子填入一个数之后，再递归执行下一个格子，这样就可以避免了单步骤内多次递归而导致状态难以恢复的问题，当递归到最后一个格子且成功填入数字时，表示所有格子匹配成功，否则恢复状态回溯到上一步骤换一个数  

上面的做法可以省略掉最开始确认唯一数的步骤；还可以对bits数组进行优化，采用row[9]，column[9]，block[3][3]，保存每一行每一列，每一个九宫格剩余可选数，这样设置状态，恢复状态的复杂度都会降低，但是这样便不能省略掉最开始确认唯一数的步骤，因为不再是每个格子单独记录自身的可选数，如果省略掉虽然也会得出正确的解，但会让后面递归的深度变大
#### <span id=0038>[38] 外观数列</span>
题目链接：[https://leetcode-cn.com/problems/count-and-say](https://leetcode-cn.com/problems/count-and-say)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0038.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0038.cpp)  
运行时间：beats 100%  
解题思路：比较简单的题目，虽然题意是考察对字符串的遍历，但实际操作起来的难点应该是在于如何减少产生临时字符串，解决方法也很简单，定义两个字符串和两个指向它们的指针，对n的每一次遍历完成后交换这两个指针即可
#### <span id=0039>[39] 组合总和</span>
题目链接：[https://leetcode-cn.com/problems/combination-sum](https://leetcode-cn.com/problems/combination-sum)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0039.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0039.cpp)  
运行时间：beats 91.52%  
解题思路：每个位置的数都可以出现0次或多次，所以可以用剩余target值除以当前位置的数值得出当前数可以出现的最大次数c，令0 <= t <= c，即当前数出现t次时递归计算下一个位置的结果，根据返回结果确认是否插入当前数。可以事先对数组进行排序减少递归深度，递归的结束条件是剩余target值为0，这时候插入新的返回数组；又或者是到达数组边界，或剩余target值小于当前数，这时候直接返回。这题递归的解法简单明了，可以容易改写成非递归模式，大体做法是设定一个回溯索引，计算出每个位置数值出现对剩余target值出现的最大次数，出现次数分别取0次或多次时计算下一个位置，回溯索引时改变出现次数，重新进入下一轮计算
#### <span id=0040>[40] 组合总和-ii</span>
题目链接：[https://leetcode-cn.com/problems/combination-sum-ii](https://leetcode-cn.com/problems/combination-sum-ii)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0040.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0040.cpp)  
运行时间：beats 90.15%  
解题思路：与上一题的思路基本一致，主要差别有两点：元素只可以选择0次或1次，其实这与选择多次没有本质区别，只是单纯的循环次数问题；另外一点是解集不能包含重复的组合，因为需要减少递归深度而事先对数组进行排序，那么可以在回溯到某元素之后，如果此元素与其后面的元素相同，便将回溯索引移动到最后一个相同元素，这样便使当前组合与已经推导过的组合包含了不同个数的相同元素，所得到的解也绝不会重复。由于上道题采用了递归解法，这题解答便采用非递归模式
#### <span id=0041>[41] 缺失的第一个正数</span>
题目链接：[https://leetcode-cn.com/problems/first-missing-positive](https://leetcode-cn.com/problems/first-missing-positive)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0041.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0041.cpp)  
运行时间：beats 83.74%  
解题思路：题目限定了时间复杂度为O(n)，所以不能使用排序，限定了常数级别的额外空间，所以也不能用哈希表，尝试了一下位操作，还是毫无头绪。点开题解看，居然是在原来的数组上操作...这应该在原来题目上增加提示，因为这不应该作为一个考点...解法很简单，因为一个长度为n的数组，所缺失的第一个正整数必然在[1, n+1]的范围内；在第一次遍历数组的时候，如果元素数值大于0且不大于数组长度，便将它与占了它位置的元素进行交换，继续处理此位置和后面位置的元素；第二次遍历的时候，如果元素与（下标值+1）不相等，则说明此位置缺失，返回（下标值+1），如果循环结束还没返回，便返回（数组长度+1）
#### <span id=0042>[42] 接雨水</span>
题目链接：[https://leetcode-cn.com/problems/trapping-rain-water](https://leetcode-cn.com/problems/trapping-rain-water)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0042.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0042.cpp)  
运行时间：beats 91.68%  
解题思路：通过观察可以发现，当某个坐标的数值大于前一个坐标的数值时，表明此坐标可以作为右边界跟前面某个坐标可以一起接雨水。所以可以设定一个栈，保存可以进行接雨水的左边界下标；在遍历过程中，如果height[i] < height[i - 1]，表明height[i]只能作为左边界接雨水，将i压入栈中；如果height[i] > height[i - 1]，表明height[i]可以作为右边界与栈中所记录的左边界接雨水，循环弹出栈中所记录的左边界直至左边界高于右边界并将雨水量进行叠加，因为当前i同样可以作为左边界与后面匹配，所以循环结束后需要继续压入i。时间空间复杂度都为O(n)
#### <span id=0043>[43] 字符串相乘</span>
题目链接：[https://leetcode-cn.com/problems/multiply-strings](https://leetcode-cn.com/problems/multiply-strings)  
代码链接：[https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0043.cpp](https://github.com/ccencon/leetcode/tree/main/leetcode_0001_0050/cpp/leetcode_0043.cpp)  
运行时间：beats 100%  
解题思路：大数乘法，将num2拆分为每一位分别与num1相乘，将结果相加；为了减少临时字符串的产生，num2和num1每一位相乘后都可以立马将乘积添加到结果中，要注意偏移和溢出；在直观的做法上，通常是将乘积前向排列，但因为string向前插入需要移动所有后面的字符，效率低下，所以可以将乘积后向排列，在最后返回结果时将结果反转即可
