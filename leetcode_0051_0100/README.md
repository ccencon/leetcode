# leetcode_0051_0100
|order|question|cpp link|
|:-|:-|:-|
|[0051](#0051)|[n-皇后](#0051)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0051.cpp)|
|[0052](#0052)|[n皇后-ii](#0052)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0052.cpp)|
|[0053](#0053)|[最大子数组和](#0053)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0053.cpp)|
|[0054](#0054)|[螺旋矩阵](#0054)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0054.cpp)|
|[0055](#0055)|[跳跃游戏](#0055)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0055.cpp)|
|[0056](#0056)|[合并区间](#0056)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0056.cpp)|
|[0057](#0057)|[插入区间](#0057)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0057.cpp)|
|[0058](#0058)|[最后一个单词的长度](#0058)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0058.cpp)|
|[0059](#0059)|[螺旋矩阵-ii](#0059)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0059.cpp)|
|[0060](#0060)|[排列序列](#0060)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0060.cpp)|
|[0061](#0061)|[旋转链表](#0061)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0061.cpp)|
|[0062](#0062)|[不同路径](#0062)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0062.cpp)|
|[0063](#0063)|[不同路径-ii](#0063)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0063.cpp)|
|[0064](#0064)|[最小路径和](#0064)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0064.cpp)|
|[0065](#0065)|[有效数字](#0065)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0065.cpp)|
|[0066](#0066)|[加一](#0066)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0066.cpp)|
|[0067](#0067)|[二进制求和](#0067)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0067.cpp)|
|[0068](#0068)|[文本左右对齐](#0068)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0068.cpp)|
|[0069](#0069)|[x-的平方根](#0069)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0069.cpp)|
|[0070](#0070)|[爬楼梯](#0070)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0070.cpp)|
|[0071](#0071)|[简化路径](#0071)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0071.cpp)|
|[0072](#0072)|[编辑距离](#0072)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0072.cpp)|
|[0073](#0073)|[矩阵置零](#0073)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0073.cpp)|
|[0074](#0074)|[搜索二维矩阵](#0074)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0074.cpp)|
|[0075](#0075)|[颜色分类](#0075)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0075.cpp)|
|[0076](#0076)|[最小覆盖子串](#0076)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0076.cpp)|
|[0077](#0077)|[组合](#0077)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0077.cpp)|
|[0078](#0078)|[子集](#0078)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0078.cpp)|
|[0079](#0079)|[单词搜索](#0079)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0079.cpp)|
|[0080](#0080)|[删除有序数组中的重复项-ii](#0080)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0080.cpp)|
|[0081](#0081)|[搜索旋转排序数组-ii](#0081)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0081.cpp)|
|[0082](#0082)|[删除排序链表中的重复元素-ii](#0082)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0082.cpp)|
|[0083](#0083)|[删除排序链表中的重复元素](#0083)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0083.cpp)|
|[0084](#0084)|[柱状图中最大的矩形](#0084)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0084.cpp)|
|[0085](#0085)|[最大矩形](#0085)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0085.cpp)|
|[0086](#0086)|[分隔链表](#0086)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0086.cpp)|
|[0087](#0087)|[扰乱字符串](#0087)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0087.cpp)|
|[0088](#0088)|[合并两个有序数组](#0088)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0088.cpp)|
|[0089](#0089)|[格雷编码](#0089)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0089.cpp)|
|[0090](#0090)|[子集-ii](#0090)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0090.cpp)|
|[0091](#0091)|[解码方法](#0091)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0091.cpp)|
|[0092](#0092)|[反转链表-ii](#0092)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0092.cpp)|
|[0093](#0093)|[复原-ip-地址](#0093)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0093.cpp)|
|[0094](#0094)|[二叉树的中序遍历](#0094)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0094.cpp)|
|[0095](#0095)|[不同的二叉搜索树-ii](#0095)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0095.cpp)|
|[0096](#0096)|[不同的二叉搜索树](#0096)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0096.cpp)|
|[0097](#0097)|[交错字符串](#0097)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0097.cpp)|
|[0098](#0098)|[验证二叉搜索树](#0098)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0098.cpp)|
|[0099](#0099)|[恢复二叉搜索树](#0099)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0099.cpp)|
|[0100](#0100)|[相同的树](#0100)|[cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0100.cpp)|

#### <span id=0051>[51] n-皇后</span>
题目链接：[https://leetcode-cn.com/problems/n-queens](https://leetcode-cn.com/problems/n-queens)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0051.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0051.cpp)  
运行时间：beats 91.39%  
解题思路：对这类回溯的问题，只要理清如何恢复状态的思路，很容易就可以写出非递归的实现，基本上就是三板斧：  
1. 初始回溯标志，一般为某个索引或索引集合，假定为traceIdx
2. 从traceIdx开始到结束确定一个新的序列，每一个位置确定的状态应该具有次序性，这样回溯的时候可以容易确定下一个状态
3. 回溯traceIdx，从后往前恢复状态，当某个位置有未执行的状态时，转到步骤2执行；若回溯了所有位置，结束执行

这种思路的解答运行时间基本都是击败100%，目前在网上还没见到类似思路的出现，都是递归或其它，这来源于当初写[有向图](https://github.com/olberix/structdata#DirectedGraph)输出所有拓扑序列和所有关键路径的做法，在当前所有回溯类的题目中，基本上采用了这种解答方式  

这题的具体做法是，设定数组保存每一行，每一列，每一条斜线的匹配状态，初始trace_i，trace_j，从开始到结束确定第一个结果，然后对trace_i，trace_j进行回溯并恢复状态，并从新的trace_i，trace_j开始确定新的结果
#### <span id=0052>[52] n皇后-ii</span>
题目链接：[https://leetcode-cn.com/problems/n-queens-ii](https://leetcode-cn.com/problems/n-queens-ii)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0052.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0052.cpp)  
运行时间：beats 100%  
解题思路：[n-皇后](#0051)一样的做法，只是将返回字符串换成了返回个数，本质上没有变化
#### <span id=0053>[53] 最大子数组和</span>
题目链接：[https://leetcode-cn.com/problems/maximum-subarray](https://leetcode-cn.com/problems/maximum-subarray)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0053.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0053.cpp)  
运行时间：beats 71.26%  
解题思路：设定prev记录以当前位置结束的最大子数组和，ans记录最大子数组和，遍历到某个pos时，如果prev + nums[pos] < nums[pos]，则prev = nums[pos]，否则prev = prev + nums[pos]，然后刷新ans
#### <span id=0054>[54] 螺旋矩阵</span>
题目链接：[https://leetcode-cn.com/problems/spiral-matrix](https://leetcode-cn.com/problems/spiral-matrix)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0054.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0054.cpp)  
运行时间：beats 100%  
解题思路：哀过程之多艰，这道中等题足足花费了两天的零碎时间。如果按照一般套路来做的话，这道题其实可以归纳为简单题，具体有两种做法：一种是给螺旋轨迹设定一个运动规则，右→下→左→上，即每运动到一个点，便依次判断右下左上是否已经到达过，选出下一个未到达过的点，直至所有点均与到达，但这种方式会存在较多分支判断，可以采用另外一种方法；另外一种方法是模拟旋转路径，按照运动轨迹一层一层地遍历，先往右走，遇到边界往下走，再然后往左走，最后往上走  

在开始码代码之前，脑海里偏向的是第二种做法，但同时也产生了一个疑问，对于m*n阶矩阵，无论这两种的哪一种解答方式，cpu cache命中率都不高，因为不是顺序遍历，而且在已知m，n大小的情况下，矩阵中的每一对下标应该都能确定在answer中的索引值，那应该如何将下标对(x,y)进行转换成i，使得能够以顺序遍历矩阵的方式解答这道题？作为一个极容易为想法而纠结的人，也由此开始了多艰的推导之旅  

> 因为索引值的规律性，第一个想法肯定是希望能够找到一个数学方程式进行统一的下标转换，即$i=f(x,y)$，在推导好一会之后发现，螺旋的特性必然要涉及到复杂的三角函数，作为一个数学渣，最后只能不甘心的放弃了这个做法；那既然统一函数不行，那分段函数呢？通过把(x,y)分为上右和左下两部分，因为这两部分的(x,y)跟i存在线性关系，不过这个推导也放弃了，因为某层的计算需要依赖上一层的状态，这样实在太过复杂  

> 第二个想法是将矩阵中每一行进行分段处理，在手动列出几种不同形式的矩阵分布后，可以发现每一行i的规律，中间i是以递增的形式，而左右两边则是以某种差值的形式进行增加或者减少，这需要确定每一对(x,y)位于螺旋中的第几层，确定i是递增还是以差值进行增加或减少的方式，这差值也比较容易计算出来，但由于不好处理矩阵左边和下边两部分，这个想法也以失败告终  

> 虽然上面几个想法行不通（应该说实现太过复杂），但也给最终的实现方式提供了基础。具体做法是，遍历到某个位置时，首先确定当前(x,y)位于螺旋的层数，那么转换后的索引值i=外层点数+位于当前层的第几个点；每一层的外层点数都可以事先计算出来，除了最里层（差8个或7个），每一层与外层必然都是差了8个点，然后再判断(x,y)是位于右上还是左下部分，即通过分段确定坐标对位于当前层的第几个点，从而计算出i值；至于矩阵中左边和下边两部分，可以将(x,y)转换为关于x轴或y轴对称的坐标点进行判断（矩阵关于原点对称）

过程是艰辛的，结果是喜悦的，网上都是清一色的push_back或append，这的确值得花文字记录一下
#### <span id=0055>[55] 跳跃游戏</span>
题目链接：[https://leetcode-cn.com/problems/jump-game](https://leetcode-cn.com/problems/jump-game)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0055.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0055.cpp)  
运行时间：beats 88.33%  
解题思路：初始变量pathLength = nums[0]，记录可以到达最大的下标，在遍历nums过程中，如果i > pathLength，则表示i点已经不可到达，返回false，如果pathLength >= 数组最大下标，则表示数组最后一点可到达，返回true
#### <span id=0056>[56] 合并区间</span>
题目链接：[https://leetcode-cn.com/problems/merge-intervals](https://leetcode-cn.com/problems/merge-intervals)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0056.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0056.cpp)  
运行时间：beats 93.82%  
解题思路：为了使两个不重叠区间因为合并了另外一个区间而变得重叠，可以先对intervals进行排序，使得区间左端点从小到大排列，然后遍历intervals数组，合并重复区间并加入到返回列表中
#### <span id=0057>[57] 插入区间</span>
题目链接：[https://leetcode-cn.com/problems/insert-interval](https://leetcode-cn.com/problems/insert-interval)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0057.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0057.cpp)  
运行时间：beats 51.65%  
解题思路：通过newInterval找到在intervals重叠的左区间下标beginIdx，因为intervals已经顺序排列，所以从beginIdx开始找到重叠的右区间下标endIdx，在intervals上合并这些区间，并将endIdx后面的元素往前移动，对intervals进行resize之后返回intervals；需要注意一些特殊情况，比如找不到beginIdx，endIdx，或endIdx小于beginIdx等
#### <span id=0058>[58] 最后一个单词的长度</span>
题目链接：[https://leetcode-cn.com/problems/length-of-last-word](https://leetcode-cn.com/problems/length-of-last-word)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0058.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0058.cpp)  
运行时间：beats 100%  
解题思路：从后往前遍历，过滤掉空格之后开始计数，直至遇到空格结束
#### <span id=0059>[59] 螺旋矩阵-ii</span>
题目链接：[https://leetcode-cn.com/problems/spiral-matrix-ii](https://leetcode-cn.com/problems/spiral-matrix-ii)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0059.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0059.cpp)  
运行时间：beats 100%  
解题思路：[54 螺旋矩阵](#0054)的反操作，54题为了提高cpu cache命中率，采用了顺序遍历矩阵的方式，将坐标对进行了转换，这题同理，为了提高cpu的回写效率，同样以顺序方式进行遍历，将坐标对转换成第几个数即可
#### <span id=0060>[60] 排列序列</span>
题目链接：[https://leetcode-cn.com/problems/permutation-sequence](https://leetcode-cn.com/problems/permutation-sequence)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0060.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0060.cpp)  
运行时间：beats 100%  
解题思路：从后往前计算排列数，比如n = 7，k = 9，计算到倒数第4位的时候发现4! == 24 >= 9，说明第9个排列必然是从倒数第4位开始变化出来的，而第1位到第3位保持原有序列"123"；从倒数第四位开始往后遍历，获取当前位置剩余的最小数num，当k大于下一个位置的最大排列数A时，表明当前位置为num时的总排列数小于k，此时将k - A，继续在当前位置获取下一个剩余最小数  
时间复杂度为O(N)，浏览评论的时候发现[康托展开](https://baike.baidu.com/item/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/7968428?fr=aladdin)能更加专业的解决这个问题
#### <span id=0061>[61] 旋转链表</span>
题目链接：[https://leetcode-cn.com/problems/rotate-list](https://leetcode-cn.com/problems/rotate-list)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0061.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0061.cpp)  
运行时间：beats 55.64%  
解题思路：由于旋转链表需要知道链表长度，所以需要提前遍历一次链表，为了不重复遍历，在事先遍历的同时用vector保存每一位置的结点，将k对length取余后，得到新的尾结点索引为length - 1 - k，将原头尾结点相连和将新尾结点置null后，返回新的头结点，位于索引length - k。事实证明，还不如多遍历一次链表，vector的申请空间和赋值操作同样耗时
#### <span id=0062>[62] 不同路径</span>
题目链接：[https://leetcode-cn.com/problems/unique-paths](https://leetcode-cn.com/problems/unique-paths)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0062.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0062.cpp)  
运行时间：beats 100%  
解题思路：高中的排列组合题，求某两个对角点最短路径的数目，比如m行n列的网格，从左上角的点到右下角的点，那么最短路径就只能往下或往右走，即往右走n次，往下走m次，不同的路径就是往下或往右走的时机不同，故路经数为 $C_{n+m}^m$ 或 $C_{n+m}^n$  
也可以采用动态规划求解，到达某点的最短路径数等于相邻两点（最短路径上）的最短路径数目之和，所以可以从起点开始，一步步往下求解  
题目是基于格子而不是点，但解法一致，m行n列的网格可以看作m-1行n-1列的格子组合，也可以看作，向右或向下少走一步，即 $C_{n+m-2}^{m-1}$ 或 $C_{n+m-2}^{n-1}$  
#### <span id=0063>[63] 不同路径-ii</span>
题目链接：[https://leetcode-cn.com/problems/unique-paths-ii](https://leetcode-cn.com/problems/unique-paths-ii)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0063.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0063.cpp)  
运行时间：beats 56.13%  
解题思路：类似[62 不同路径](#0062)，由于在网格中加入了障碍物，所以上述两种方法中只能选择dp求解
#### <span id=0064>[64] 最小路径和</span>
题目链接：[https://leetcode-cn.com/problems/minimum-path-sum](https://leetcode-cn.com/problems/minimum-path-sum)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0064.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0064.cpp)  
运行时间：beats 76.92%  
解题思路：类似[63 不同路径-ii](#0063)，只是记录路径数变成记录了最小路径和
#### <span id=0065>[65] 有效数字</span>
题目链接：[https://leetcode-cn.com/problems/valid-number](https://leetcode-cn.com/problems/valid-number)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0065.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0065.cpp)  
运行时间：beats 58.06%  
解题思路：有效数字的状态不多，可以很容易的通过分支判断进行解答，但是相比之下，有限状态自动机的做法才是正途，将每一个状态都作为状态转换的枢纽，简化转换策略，思路更加清晰简洁  
参考：[确定有限状态自动机](https://leetcode.cn/problems/valid-number/solution/you-xiao-shu-zi-by-leetcode-solution-298l/) [有限状态自动机](https://zhuanlan.zhihu.com/p/400108593) [有限自动机](https://baike.baidu.com/item/%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA/8700995?fr=aladdin)
#### <span id=0066>[66] 加一</span>
题目链接：[https://leetcode-cn.com/problems/plus-one](https://leetcode-cn.com/problems/plus-one)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0066.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0066.cpp)  
运行时间：beats 100%  
解题思路：设置溢出位从后往前加，如果溢出位为0，提前结束返回，如果遍历结束后仍没有返回，则说明此时溢出位为1，往数组头部插入1返回即可
#### <span id=0067>[67] 二进制求和</span>
题目链接：[https://leetcode-cn.com/problems/add-binary](https://leetcode-cn.com/problems/add-binary)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0067.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0067.cpp)  
运行时间：beats 100%  
解题思路：设置溢出位从后往前加，先加两个字符串处于同一加法位置的部分，再单独加最长字符串的剩余部分，如果到最后仍然有溢出位，则向返回字符串头部插入'1'
#### <span id=0068>[68] 文本左右对齐</span>
题目链接：[https://leetcode-cn.com/problems/text-justification](https://leetcode-cn.com/problems/text-justification)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0068.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0068.cpp)  
运行时间：beats 100%  
解题思路：有点奇怪的题目，没有get到考察点。具体做法很简单，首先尽可能多的放置单词，即每个单词之间只留一个空格，长度超出maxWidth时结束放置，期间记录所有单词总长度length，这时候通过(maxWidth - length) / 空格集合数，计算出当前空格集合应该放置多少个空格c，因为左边空格必须多于右边空格，当c * 空格集合数 != maxWidth - length时，c自增1；循环计算，直至插完当前的所有单词；当插入的是最后一行时，特殊处理一下，即每个单词间空格数恒定为1
#### <span id=0069>[69] x-的平方根</span>
题目链接：[https://leetcode-cn.com/problems/sqrtx](https://leetcode-cn.com/problems/sqrtx)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0069.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0069.cpp)  
运行时间：beats 100%  
解题思路：采用二分法进行渐进处理，其中右边数为min(x/2+1, 46340)，其中46340是2^31-1的平方根，故所有数平方根必然不大于46340。[题解](https://leetcode.cn/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/)中的 **袖珍计算器算法** 和 **牛顿迭代** 能更巧妙的解决这道题
#### <span id=0070>[70] 爬楼梯</span>
题目链接：[https://leetcode-cn.com/problems/climbing-stairs](https://leetcode-cn.com/problems/climbing-stairs)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0070.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0070.cpp)  
运行时间：beats 100%  
解题思路：斐波那契数列问题，题目要求每次只能走1个或2个台阶，所以从第三项开始，每一项等于前面两项之和，通俗点理解就是前第2项走2个台阶到达当前台阶，前第1项走1个台阶到达当前台阶，故当前台阶走法等于前两项之和  
也可以采用排列组合的思想解答，假设走0个2阶，走法有 $C_n^0$ 种，走1个两阶时，走法有 $C_{n-1}^1$ 种，走2个两阶时，走法有 $C_{n-2}^2$ 种，将所有和相加便得到第n阶台阶的走法。组合的方式适用于每次走法只能两种的情况，当存在多种走法时，计算组合数将会变得繁杂，这个时候还是斐波那契数列的解法比较简单
#### <span id=0071>[71] 简化路径</span>
题目链接：[https://leetcode-cn.com/problems/simplify-path](https://leetcode-cn.com/problems/simplify-path)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0071.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0071.cpp)  
运行时间：beats 100%  
解题思路：可以使用双向队列记录目录名，遇到'.'忽略，遇到'..'弹出尾部元素，遇到目录或文件名尾部插入，最后组装返回。但这种方式会产生过多临时变量，从而导致内存拷贝的开销，可以初始化一个返回字符串ans，遇到文件名插入，遇到'..'便回溯到上一个文件名，因为涉及到'/'的状态简单，这种方法的思路也清晰明了，可以有效的减少内存拷贝，提升效率
#### <span id=0072>[72] 编辑距离</span>
题目链接：[https://leetcode-cn.com/problems/edit-distance](https://leetcode-cn.com/problems/edit-distance)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0072.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0072.cpp)  
运行时间：beats 49.01%  
解题思路：一般题目在看完之后意识里都会有一个符合直观的大致方向，而这道两个单词转换的题目完全不符合人的直观思维，在苦思良久之后还是毫无头绪，最终还是借助了官方题解进行理解，以官方例子"horse"-->"ros"为例，要计算出它们的最小转换次数，可以先计算出下面3种情况的最小转换次数：  
1. "hors"-->"ro"，对应 **替换** 操作，这个时候需要将"horse"中剩余未转换的'e'替换成's'，假设D("hors", "ro")=k，那么D("horse", "ros")=k+1；特殊情况是，如果他们的后一个字符相同，则不需要进行替换操作，如D("horss", "ros")=k
2. "horse"-->"ro"，对应 **插入** 操作，这个时候需要往转换后的"horse"中插入's'，形成"ros"，假设D("horse", "ro")=m，那么D("horse", "ros")=m+1
3. "hors"-->"ros"，对应 **删除** 操作，这个时候需要将"horse"中剩余未转换的'e'删除，假设D("hors", "ro")=k，那么D("horse", "ros")=k+1

由上可知，当计算D(i, j)时，如果word1[i] == word2[j]，那么D(i, j) = D(i-1, j-1)，否则，D(i, j) = min(k, m, n) + 1。在评论看到一个很有意思的问题，就是word1[i] == word2[j]时，D(i, j) = D(i-1, j-1)，为什么不需要继续进行min(D(i-1, j-1), m+1, n+1)的比较，这是因为在i或j在递增过程中，D的取值要么多1，要么少1，比如D(i-1, j-1)和D(i, j-1)，D(i-1, j-1)永远小于或等于D(i, j-1) + 1  

很久之前便发现一个现象，即使是在网上写文章，写博客的作者，绝大部分对所讨论的内容其实都是一知半解，基本上都是对着教材或者前人的文章进行换汤不换药，理解要么片面，要么停留于表面，若是对某个知识点进行深入或者对知识点换一个角度进行解释，估计大部分都会不知所语。比如这道题，在看过题解之后，大部分人都知道可以采用动态规划进行解答，D(i, j)要么继承D(i-1, j-1)，要么继承D(i, j-1)，要么继承D(i-1, j)，解释彷佛也比较简单，对应替换，插入，删除操作；大多数人的理解都止于此，但这种理解是经不起考验的，因为当换一个题目的时候，往往又会陷入无从下手的困境。  

一个问题往往都会一个直观求解的过程，当问题过于复杂偏离人的直观，这个求解过程大多数时候都比较暴力，但永远不能因为得到了某种“最优解”而忽视这个暴力过程，因为最优解往往都是基于暴力解法的思路和优化，这可以看作从本质到现象；当跨过暴力解法直接得到最优解法的时候，应该反过来对暴力解法进行推导，这可以看作从现象看本质，只有摸清本质，才算真正理解并解决了问题  

回到题目，从dp的解法来看，求解D(i, j)，需要先求解D(i-1, j-1)，D(i, j-1)，D(i-1, j)，这是一个从前往后的过程（实际操作也可以从后往前，因为思路是对称的）；所以不妨直接从前往后看，对于word1中的每一个字符，要转换成word2，都要经历下面4个步骤之一：**不变，替换，删除，增加**（这个增加指的是字符前增加，假设当前转换word1[i]-->word2[j]，如果word1[i]== word2[j]，这时候对应的步骤应该是不变，如果不相等往后增加字符是没有意义的，只有往i前增加一个word2[j]才能完成转换）；所以对每一对i，j进行求解，就是当i分别选择**不变，替换，删除，增加**时的最小转换次数  

这是一个从现象看本质的过程，具体代码看链接
#### <span id=0073>[73] 矩阵置零</span>
题目链接：[https://leetcode-cn.com/problems/set-matrix-zeroes](https://leetcode-cn.com/problems/set-matrix-zeroes)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0073.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0073.cpp)  
运行时间：beats 76.12%  
解题思路：向来对空间不太感冒。设定数组row_flag，哈希表column_flag，对matrix进行第一次遍历，matrix[i][j]等于0时，将row_flag[i]置true，column_flag插入j；对matrix进行第二次遍历，当row_flag[i]为true时，整行置0，否则，遍历column_flag，将对应j的位置置0。事后发现column_flag应该改用数组存储，效率会更好一点
#### <span id=0074>[74] 搜索二维矩阵</span>
题目链接：[https://leetcode-cn.com/problems/search-a-2d-matrix](https://leetcode-cn.com/problems/search-a-2d-matrix)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0074.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0074.cpp)  
运行时间：beats 72.86%  
解题思路：遍历matrix，找到最后一个元素比target小的一维数组，然后在这个数组上进行二分查找
#### <span id=0075>[75] 颜色分类</span>
题目链接：[https://leetcode-cn.com/problems/sort-colors](https://leetcode-cn.com/problems/sort-colors)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0075.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0075.cpp)  
运行时间：beats 40.51%  
解题思路：因为只有'0 1 2'三位数字，所以不需要使用普通的排序方式对数组进行排序，可以先遍历一次数组，计算出数字总和与数字'1'的个数，然后通过总和与'1'的个数计算出其它两个数字个数，然后按照个数重写数组即可。这种方法需要对数组进行两次遍历，可以采用3指针的方式，仅需一次遍历：设置指针p0指向数组头，p2指向数组尾，pm从p0开始往p2移动，如果nums[pm]等于0，与p0所指向的数进行交换，如果nums[pm]等于2，便与p2所指向的数进行交换，直至pm大于等于p2
#### <span id=0076>[76] 最小覆盖子串</span>
题目链接：[https://leetcode-cn.com/problems/minimum-window-substring](https://leetcode-cn.com/problems/minimum-window-substring)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0076.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0076.cpp)  
运行时间：beats 66.49%  
解题思路：用哈希表T记录t中出现的字母次数，哈希表S记录已遍历s中出现t字母的次数，队列Q记录s中出现t字母的下标，同时为了方便判断遍历s的时候是否包含了t中所有字母，设置num为t中所有字母之和，对s进行遍历，如果字母c存在于t中，执行以下操作：  
1. 将字母c的坐标压入Q中，同时S[c]++
2. 如果S[c] <= T[c]，那么num -= c；如果此时num为0，说明匹配了t中所有字母，便不断弹出Q队首元素直至S中记录的队首元素对应的字母个数等于T中的记录，然后通过新的队首元素e和队尾元素刷新最短长度；最后将num加上s[e]，rec_map[s[e]]--，弹出e进行下一轮遍历寻找s[e]
#### <span id=0077>[77] 组合</span>
题目链接：[https://leetcode-cn.com/problems/combinations](https://leetcode-cn.com/problems/combinations)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0077.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0077.cpp)  
运行时间：beats 98.7%  
解题思路：初始tmp="123..k-1"，故第k个数的取值从k到n，分别插入后，然后对tmp回溯到第k-1个数，对其加一，此时第k个数取值变为k-1到n；重复上面步骤，当第k-1个数超出它的最大值时，便继续回溯到第k-2个数，重复以上步骤，直至回溯索引小于0
#### <span id=0078>[78] 子集</span>
题目链接：[https://leetcode-cn.com/problems/subsets](https://leetcode-cn.com/problems/subsets)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0078.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0078.cpp)  
运行时间：beats 100%  
解题思路：因为对于集合中每个元素，都只存在出现和不出现两种情况，故一个有n个元素的集合的所有子集数为2^n，又因为只存在两种情况，所以可以使用位计数法对子集数进行迭代以消除回溯的步骤。同样的，也可以使用递归方法进行解答，对当前的数执行以上两种情况下的操作
#### <span id=0079>[79] 单词搜索</span>
题目链接：[https://leetcode-cn.com/problems/word-search](https://leetcode-cn.com/problems/word-search)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0079.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0079.cpp)  
运行时间：beats 42.65%  
解题思路：深度优先搜索的一个非常典型的应用，以前写过的消消乐也是类似需求，在一个二维数组内进行DFS，遵循上→右→下→左的递归顺序。题目在最后的进阶提示能否用搜索剪枝的技术来优化解决方案，最开始想到的采用类似KMP算法的解决方案，对word进行运算，计算出某个字母匹配失败的时候应该回退到哪个字符，但对单词来说貌似效率不会太高；于是用另外一个数组flag进行记录，当第k个字母失配时，路径上的坐标在flag记录上各自对应的k，表示这些坐标作为第x个字符进行匹配时，不会成功。这种剪枝方案在提交的运行时间上还不如未优化的方案，这应该是跟测试用例有关，如果是类似迷宫那种存在比较多的重复集合，这种方案应该会比较理想
#### <span id=0080>[80] 删除有序数组中的重复项-ii</span>
题目链接：[https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0080.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0080.cpp)  
运行时间：beats 31.55%  
解题思路：采用双指针做法，指针forward向前移动，遇到不同的元素前停下，从指针back开始赋值最多2个forward所指向的元素，重复这些步骤直至forward移动到数组末尾。官方的双指针思路更加优雅
#### <span id=0081>[81] 搜索旋转排序数组-ii</span>
题目链接：[https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0081.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0081.cpp)  
运行时间：beats 83.22%  
解题思路：折腾了一个下午，最终还是借助了官方题解以自己的方式完成解答。当初做[搜索旋转排序数组](https://github.com/olberix/leetcode/tree/main/leetcode_0001_0050/#0033)的时候，采用的是先找到旋转点，再进行二分查找的做法，但事实上可以直接在原旋转数组进行二分查找。这题类似，不同点在于存在重复元素，当存在重复元素的时候会发生nums[left] == nums[mid] == nums[right]的情况，这时候就不知道数组的旋转点位于mid的左边还是右边；受官方思路的启发，解决这种情况也很简单，不断靠拢left，right就行，直至三者不全相等
#### <span id=0082>[82] 删除排序链表中的重复元素-ii</span>
题目链接：[https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0082.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0082.cpp)  
运行时间：beats 100%  
解题思路：最开始理解错了题意，以为是去重，提交失败之后才发现是去除所有重复元素，不过按照leetcode的套路，紧挨着的第83题必然是去重，于是用原本82题的错误答案去提交了第83题...大体做法是双指针思路，设定指针slow和fast，如果fast前面没有重复元素，则slow->next = fast，slow = fast，否则忽略；为了方便头结点的操作，可以设定一个新的头结点hair指向原头结点，最后返回hair.next
#### <span id=0083>[83] 删除排序链表中的重复元素</span>
题目链接：[https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0083.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0083.cpp)  
运行时间：beats 98.52%  
解题思路：链表的去重，同样是双指针操作，没什么好说的
#### <span id=0084>[84] 柱状图中最大的矩形</span>
题目链接：[https://leetcode-cn.com/problems/largest-rectangle-in-histogram](https://leetcode-cn.com/problems/largest-rectangle-in-histogram)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0084.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0084.cpp)  
运行时间：beats 32%  
解题思路：一开始希望能以纯粹的O(n)时间复杂度解答，大体做法是遇到递增的矩形集合时刷新最大面积，但是这样相邻集合的面积难以协调计算，时间复杂度也退化到了O(n^2)。在官方题解的启发下，学会了使用单调栈来解答，事先遍历一次数组，计算出当前柱形左右两边形成最大矩形面积的边界，最后再遍历一次数组，通过两个边界相减再乘以当前高度刷新最大面积。官方题解还是比较“官方”的，但是cpp的运行时间只打败了32-51%的提交，这应该还有能继续优化的方法，看评论发现可以向数组插入一个哨兵减少分支判断，这的确精妙，但是运行时间依然不理想；继续往下翻评论，发现一个能以一次循环进行解答的方法，在单调栈处理的过程中，栈中元素左边界或者右边界已知，这时候只需要在当前循环刷新面积即可，提交之后发现运行时间打败了76%，时间的优化在于两个边界数组的创建和赋值处理；继续往下翻评论，也没能发现运行时间更理想的做法了
#### <span id=0085>[85] 最大矩形</span>
题目链接：[https://leetcode-cn.com/problems/maximal-rectangle](https://leetcode-cn.com/problems/maximal-rectangle)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0085.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0085.cpp)  
运行时间：beats 68.79%  
解题思路：[最大矩形](#0085)可以转化为[柱状图中最大的矩形](#0084)的求解，用heights数组记录matrix当前行的每一列的柱形高度，然后通过单调栈的方式求得当前最大矩形，时间复杂度为O(mn)；此题同样可以采用BF的方式进行求解，具体操作为用二维数组记录每一行每一列连续'1'的数目，假设遍历到位置(i, j)，设定高度从1开始往上生长，设定长为二维数组记录的最小值，将高度乘以长刷新最大矩形面积，时间复杂度为O(m^2n)
#### <span id=0086>[86] 分隔链表</span>
题目链接：[https://leetcode-cn.com/problems/partition-list](https://leetcode-cn.com/problems/partition-list)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0086.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0086.cpp)  
运行时间：beats 89.7%  
解题思路：双指针策略，fast往后遍历，遇到比x小的扔到slow后面，同时slow往后移；官方的解法更加巧妙，遇到比x小的结点合并到small链表，比x大的合并到large链表，最后将两个链表合并，但如果从效率上看，两种做法应该相差不大
#### <span id=0087>[87] 扰乱字符串</span>
题目链接：[https://leetcode-cn.com/problems/scramble-string](https://leetcode-cn.com/problems/scramble-string)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0087.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0087.cpp)  
运行时间：beats 98.65%  
解题思路：s2作为s1的扰乱字符串，是s1于某个随机下标处进行分割，然后选择是否进行交换，再对分割后的两部分递归执行以上操作得到，所以可以对s1，s2进行遍历，将s1开头和结尾，s2开头的字符添加到独立的变量当中进行排序，当它们相等时，表示可以在当前位置进行分割，然后递归判断两部分字符串是否是扰乱字符串，递归的结束条件是长度为1，且s1 == s2。由于在递归过程中会对字符串产生重复的判断操作，所以可以使用记忆化搜索，用哈希表记录两个字符串的执行结果。这题比较容易让人纠结的点在于如何判断两个子串包含了相等的字符集合，解决方法是将字符插入到字符串变量之后对字符串进行一次排序，因为每次插入前字符串都是有序的，所以可以采用二分法对字符串进行优化插入，同时为了减少字符拷贝，可以采用lambda表达式对s1，s2进行引用捕获，传入对应下标和长度即可，但由于测试用例s1，s2的长度问题，优化版本对未优化版本的提升不是特别明显
#### <span id=0088>[88] 合并两个有序数组</span>
题目链接：[https://leetcode-cn.com/problems/merge-sorted-array](https://leetcode-cn.com/problems/merge-sorted-array)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0088.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0088.cpp)  
运行时间：beats 100%  
解题思路：由于nums1末尾存储了0，所以为了减少元素的拷贝，可以从数组末尾开始合并元素，令total = m + n，取nums1[m]，nums2[n]较大者合并到nums1[total]，同时total和对应m或n自减1，当某一方合并完成后，合并剩余元素即可
#### <span id=0089>[89] 格雷编码</span>
题目链接：[https://leetcode-cn.com/problems/gray-code](https://leetcode-cn.com/problems/gray-code)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0089.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0089.cpp)  
运行时间：beats 58.73%  
解题思路：[格雷码](https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858?fr=aladdin)的转换方法通常有以下四种：递归生成码表，异或转换，卡诺图，异或乘除，前两种因为实现简单而最为常见，这里采用了第二种异或转换进行解答，下面是异或转换的证明：假设a = b + 1，则在a和b的二进制表示中，b最末尾开始连续的1将会变为0，而从末尾开始的第一个0将会变为1，从而形成了a，因为异或运算是相同为0，不同为1，a ^ (a >> 1)和b ^ (b >> 1)错位异或只会有一位不同（0变为1的那一位，本质就是异或1进行取反），从而形成了格雷码，且格雷码的取值范围为[0, 2^n - 1]
#### <span id=0090>[90] 子集-ii</span>
题目链接：[https://leetcode-cn.com/problems/subsets-ii](https://leetcode-cn.com/problems/subsets-ii)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0090.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0090.cpp)  
运行时间：beats 54.1%  
解题思路：第[[78] 子集](#0078)的兄弟版本，区别在于此题会包含重复元素，一开始想用第78题类似的解法，但是纠结于如何判断已经包含重复元素；于是便采用递归的方法，每碰到一个元素，便分为包含和不包含两种情况进行递归，如果碰到的是重复元素，便计算出重复元素的个数，按照取0个，1个，2个...的情况递归。后来浏览题解的时候发现，采用第78题的方式也可以很好解决包含重复元素的问题，具体方法是遇到重复元素时，如果上一个元素没有被选取，则跳过当前元素，因为上一位的变化已经是从1变0，代表重复元素已经被选取
#### <span id=0091>[91] 解码方法</span>
题目链接：[https://leetcode-cn.com/problems/decode-ways](https://leetcode-cn.com/problems/decode-ways)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0091.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0091.cpp)  
运行时间：beats 100%  
解题思路：对于当前位置的数字，如果它可以单独组成一个字母，则当前位置继承前一个位置的解码数目，如果与前一个位置同样可以组成一个字母，则同样继承前第二个位置的解法数目，故可以采用动态规划的求解方式，时间复杂度为O(N)；也可以采用递归的方法，以当前位置取一个数和两个数进行递归求解，不过时间复杂度会退化到O(2^N)
#### <span id=0092>[92] 反转链表-ii</span>
题目链接：[https://leetcode-cn.com/problems/reverse-linked-list-ii](https://leetcode-cn.com/problems/reverse-linked-list-ii)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0092.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0092.cpp)  
运行时间：beats 100%  
解题思路：先确认插入的基准点，然后对区间进行遍历，将每一次遍历到的结点都插入到基准点后面，最后链接right后面的结点
#### <span id=0093>[93] 复原-ip-地址</span>
题目链接：[https://leetcode-cn.com/problems/restore-ip-addresses](https://leetcode-cn.com/problems/restore-ip-addresses)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0093.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0093.cpp)  
运行时间：beats 100%  
解题思路：对于这种回溯类的题目，可以采用类似[[51] n-皇后](#0051)的思路代替递归，这里不再详细叙述
#### <span id=0094>[94] 二叉树的中序遍历</span>
题目链接：[https://leetcode-cn.com/problems/binary-tree-inorder-traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0094.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0094.cpp)  
运行时间：beats 40.8%  
解题思路：手撕过[线索AVL树](https://github.com/olberix/structdata#5)，[红黑树](https://github.com/olberix/structdata#6)，基于磁盘聚簇实现的[B-树](https://github.com/olberix/structdata#7)，非聚簇实现的[B+树](https://github.com/olberix/structdata#8)，树的中序遍历还是非常简单的
#### <span id=0095>[95] 不同的二叉搜索树-ii</span>
题目链接：[https://leetcode-cn.com/problems/unique-binary-search-trees-ii](https://leetcode-cn.com/problems/unique-binary-search-trees-ii)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0095.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0095.cpp)  
运行时间：beats 76.56%  
解题思路：先做的下一题再回到这题，居然还做不出来，深受打击，结果看了题解才发现自己理解错了题意，题目的意思是返回不同树的根结点组成的列表，但是受到题目例子输出的影响，一直以为返回的是不同树的层序遍历结果组成的列表，真是蛋疼，一下午时间就这么没了...
#### <span id=0096>[96] 不同的二叉搜索树</span>
题目链接：[https://leetcode-cn.com/problems/unique-binary-search-trees](https://leetcode-cn.com/problems/unique-binary-search-trees)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0096.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0096.cpp)  
运行时间：beats 100%  
解题思路：这题苦思良久还是没做出来...其实在一开始就陷入了死胡同，应该说是一条很复杂的胡同，奇怪于为什么题目需要额外告诉我们一个结点编号，所谓不同的二叉搜索树不就是形状不一样的树吗，为什么还需要编号这东西？所以在一开始就没有借助编号进行解答，而是基于“一棵具有n个结点的二叉树必然有n+1个空指针”的思想尝试求解，比如结点数为2不同的树有两棵，它有2+1=3个空指针，那么结点数加1变为3时，不同树的棵数为2*3=6棵，然后这6棵树里面会包含重复的树，所以还需要进行去重，最终在这条去重，包含微弱曙光的黑暗道路上越走越远...  

先记录一下官方题解，这对后面自己的推导具有启发式的帮助。假设有一棵结点数为n的二叉搜索树，结点编号为1，2，3，...，n，当编号1为根结点时，这时候树的数目为 $G(0)*G(n-1)$；当编号2为根结点时，这时候树的数目为 $G(1)*G(n-2)$，上述的 $G(0),G(1)$ 为左子树数， $G(n-1),G(n-2)$ 为右子树数，故有 $G(n)=G(0)G(n-1)+G(1)G(n-2)+G(2)G(n-3)+...+G(n-1)G(0)=\sum_{i=1}^{n}G(i-1)G(n-i)$；所以可以采用动态规划的思想，使结点数n从2开始递增，分别求解当左子树数取0，1，2...对应右子树数取n-1，n-2，n-3...时的树的数目，再将所有结果相加便得出当前结点数n的二叉搜索树数目  

特别地，上述 $G(n)$ 的函数值在数学上被称为卡特兰数 $C_n$，[这里](https://zhuanlan.zhihu.com/p/97619085)有对卡特兰数的详细介绍，里面说到卡特兰数问题经过一定转换都可以还原成进栈出栈的问题，以里面最简单的例子为例：n 个元素进栈序列为：1，2，3，4，...，n，则有多少种出栈序列？题目的解决方法是通过总序列数减去非法序列数，总序列数为组合数 $C_{2n}^{n}$，而非法序列数文章中用了一种"取巧"的方法计算，因为非法序列就是出现前缀和小于0的序列，对这个前缀进行取反后得到一个新序列，新序列有n+1个"+1"和n-1个"-1"，因为转换前后的序列一一对应，所以非法序列数为 $C_{2n}^{n+1}$；$C_{2n}^{n+1}$ 其实可以通过另外一种更加“传统”的方式计得，当非法序列第一个数为"-1"时，这时候的序列数为 $C_{2n-1}^{n}$；当前两个数都为"-1"时，这时候的序列数为 $C_{2n-2}^{n}$；... 当前n个数都为"-1"时，这时候的序列数为 $C_{2n-n}^{n}$ ；所以总非法序列数为 $C_{2n-1}^{n}+C_{2n-2}^{n}+...+C_{2n-n}^{n}$ ，将式子反转成 $C_{n}^{n}+C_{n+1}^{n}+...+C_{2n-1}^{n}$，将第一项转化为 $C_{n+1}^{n+1}$，通过消项相加得出和为 $C_{2n}^{n+1}$。故合法的出栈序列数目为 $C_{2n}^{n}-C_{2n}^{n+1}=\frac{C_{2n}^{n}}{n+1}$，而 $\frac{C_{2n}^{n}}{n+1}$ 也是卡特兰数的通项公式，因为程序计算的特殊性，在计算卡特兰数时，往往是通过递推公式求得： $C_{n+1}=\frac{4n+2}{n+2}C_n$ 或 $C_{n}=\frac{4n-2}{n+1}C_{n-1}$  

那么像原题目中的不同的二叉搜索树该怎么转变为进栈出栈的问题呢？btw，这个转变足足花费了昨天一下午的摸鱼时间，不过这个时间很值得，这个思路跟原创的[螺旋矩阵](#0054)和[非递归回溯](#0051)一样，翻遍全网也没有同样的思路...留意到介绍卡特兰数文章中有这么一道题：有n+1个叶子结点能够构成多少种形状不同的（国际）满二叉树？这也是非常简单的进出栈问题，（国际）满二叉树的结点要么无孩子，要么两个孩子，所有可以用"+1"表示左孩子，"-1"表示右孩子，左右孩子数目相等，故不同的（国际）满二叉树数目为 $\frac{C_{2n}^{n}}{n+1}$；回到这个题目，不妨把二叉搜索树的null结点看作一个具体的结点，那么一种二叉搜索树就唯一对应了一种（国际）满二叉树，又因为二叉搜索树必然有n+1个null结点，所以不同的二叉搜索树数目同样为 $\frac{C_{2n}^{n}}{n+1}$，通过这种进出栈思想可以直接跳过官方题解中的推导过程，一步到位
#### <span id=0097>[97] 交错字符串</span>
题目链接：[https://leetcode-cn.com/problems/interleaving-string](https://leetcode-cn.com/problems/interleaving-string)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0097.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0097.cpp)  
运行时间：beats 23%  
解题思路：较为简单的回溯问题，优先匹配s1，s1匹配不上便匹配s2，都匹配不上便进行回溯，即遇到原本匹配s1的字符便改为匹配s2，重复以上操作直至匹配完成。不过在提交时遇到"ababab.."和"bababa.."类型的测试用例时超时，这时候意识到需要进行记忆化剪枝；在这里花了很多时间，想了很久才理清思路如何记忆化：在s3的匹配过程中，记录此时s1和s2已经匹配的字符数，在往后匹配失败进行回溯再一次匹配到某字符时，如果发现s1和s2已经匹配的字符数在之前的匹配过程中出现过，因为是从前往后匹配，证明往后匹配已经失败过，可以继续进行回溯

在写解题思路时突然发现，上述记忆化的思路可以换个角度理解，就是失败回溯时，证明以当前s1剩下的字符数和s2剩下的字符数不能够匹配s3剩下的字符

这个角度转换很容易带来递归写法的实现，在遇到回溯类的题目时，很喜欢使用非递归的实现，因为效率更高，更加复杂难以理解，但这次运行时间却不理想，估计是使用数据结构的问题，解这题花了很多时间，这里也不再纠结了
#### <span id=0098>[98] 验证二叉搜索树</span>
题目链接：[https://leetcode-cn.com/problems/validate-binary-search-tree](https://leetcode-cn.com/problems/validate-binary-search-tree)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0098.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0098.cpp)  
运行时间：beats 85.78%  
解题思路：一开始想当然的以为层级遍历就可以解决，只需判断当前结点和左右结点的值便可，结果提交时毫无疑问被打脸。因为两棵满足条件的树组合在一起不一定还满足条件，于是乎还是老老实实按照中序遍历的方式进行比较解答
#### <span id=0099>[99] 恢复二叉搜索树</span>
题目链接：[https://leetcode-cn.com/problems/recover-binary-search-tree](https://leetcode-cn.com/problems/recover-binary-search-tree)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0099.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0099.cpp)  
运行时间：beats 10.34%  
解题思路：解答时思路有点混乱，中序遍历的时候遇到打乱的结点不清楚应该交换哪几个，所以干脆用容器保存打乱的结点（最多4个），然后进行排序，因为最终只有打乱的两个结点会交换顺序，所以找到这两个结点交换即可。在对比官方题解之后，发现自己应该列举几个例子进行比较，这样思路会更加清晰；比如序列“1 7 2 4 5 6 3 8”...，其实就只需要交换7和3，但因为自己理不清思路，觉得7、2、6、3任意两个都有可能进行交换，所以画蛇添足用容器进行了保存排序
#### <span id=0100>[100] 相同的树</span>
题目链接：[https://leetcode-cn.com/problems/same-tree](https://leetcode-cn.com/problems/same-tree)  
代码链接：[https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0100.cpp](https://github.com/olberix/leetcode/tree/main/leetcode_0051_0100/cpp/leetcode_0100.cpp)  
运行时间：beats 100%  
解题思路：遍历比较两棵树的结点即可，这里使用基于广度优先的层级遍历
